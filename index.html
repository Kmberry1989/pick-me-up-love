<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Claw Crane Game - Coin & Ticket System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
            touch-action: none;
        }

        button {
            border: none;
            cursor: pointer;
            user-select: none;
        }

        #insertCoin {
            display: none;
        }

        #toggleCatalog {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #0088ff;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 4px;
            color: white;
        }

        #catalog {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 6px;
            display: none;
            z-index: 20;
        }

        #winBanner {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            padding: 10px 26px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.25);
            border-radius: 18px;
            color: #fff2b0;
            font-size: 20px;
            letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(255, 242, 176, 0.8);
            opacity: 0;
            z-index: 26;
            pointer-events: none;
        }

        #winBanner.show {
            animation: win-pop 1.2s ease-out forwards;
        }

        @keyframes win-pop {
            0% { opacity: 0; transform: translateX(-50%) scale(0.6); }
            20% { opacity: 1; transform: translateX(-50%) scale(1.1); }
            60% { opacity: 1; transform: translateX(-50%) scale(1); }
            100% { opacity: 0; transform: translateX(-50%) scale(0.9); }
        }

        #coinTray {
            width: 86px;
            height: 86px;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .panel-coin {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .coin {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff3b0, #f1c453 55%, #a97b1d 100%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            color: #3b2a05;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            user-select: none;
            pointer-events: auto;
        }

        .coin:active {
            cursor: grabbing;
        }

        #coinSlotUI {
            position: relative;
            width: 72px;
            height: 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.25);
            border-radius: 10px;
            transform: rotate(-12deg);
            z-index: 28;
            pointer-events: none;
            box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.6);
            margin-left: -8px;
        }

        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 9999;
            pointer-events: none;
            transition: opacity 3s ease-in-out;
            opacity: 1;
        }

        #ui-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 240px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 30px;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 30;
        }

        .control-panel {
            background: #2c3e50;
            padding: 20px 40px;
            border-radius: 20px;
            border: 4px solid #c0392b;
            display: flex;
            gap: 26px;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            align-items: center;
            position: relative;
        }

        #joystick-zone {
            width: 120px;
            height: 120px;
            position: relative;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            border: 4px solid #7f8c8d;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            height: 12px;
            background: linear-gradient(to bottom, #95a5a6, #7f8c8d);
            transform-origin: 0 50%;
            pointer-events: none;
            z-index: 5;
            border-radius: 6px;
            width: 0px;
            transform: translate(0, -50%) rotate(0deg);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        #joystick-knob {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #e74c3c, #c0392b);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 10;
        }

        .btn-action {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            background: #e74c3c;
            color: white;
            font-size: 1.4rem;
            font-weight: 900;
            border: none;
            box-shadow: 0 8px 0 #962c22, 0 0 20px rgba(231, 76, 60, 0.4);
            cursor: pointer;
            transition: all 0.1s;
        }
        .btn-action:active { transform: translateY(8px); box-shadow: 0 0 0 #962c22; }
        .btn-action[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.3);
            box-shadow: none;
        }

        .display-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .display-group.compact .lcd-val {
            font-size: 22px;
        }

        .display {
            background: #000;
            color: #e74c3c;
            font-family: 'Courier New', monospace;
            padding: 10px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            text-align: right;
            min-width: 80px;
        }
        .lcd-label { font-size: 11px; color: #95a5a6; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;}
        .lcd-val { font-size: 28px; line-height: 1; text-shadow: 0 0 5px #e74c3c; }

        #toggleCatalog {
            top: 10px;
            right: 10px;
            z-index: 40;
        }

        #catalog h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
        }

        .catalog-item {
            margin: 4px 0;
            cursor: pointer;
            padding: 5px;
            border-bottom: 1px solid #333;
        }

        .catalog-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .catalog-item span {
            float: right;
        }

        canvas {
            display: block;
        }

        @media (max-width: 700px) {
            #ui-layer {
                height: 200px;
                padding-bottom: 18px;
            }

            .control-panel {
                padding: 14px 18px;
                gap: 16px;
                flex-wrap: wrap;
                justify-content: center;
            }

            #joystick-zone {
                width: 90px;
                height: 90px;
            }

            #joystick-knob {
                width: 46px;
                height: 46px;
            }

            .btn-action {
                width: 90px;
                height: 90px;
                font-size: 1.1rem;
            }

            #coinTray {
                width: 64px;
                height: 64px;
            }

            .coin {
                width: 48px;
                height: 48px;
                font-size: 10px;
            }

            .display-group.compact .lcd-val {
                font-size: 18px;
            }

            #toggleCatalog {
                top: 8px;
                right: 8px;
                padding: 8px 10px;
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <div id="fade-overlay"></div>
    <div id="winBanner">JACKPOT!</div>

    <button id="insertCoin">üí∞ Insert Coin</button>
    <button id="toggleCatalog">üéÅ Catalog</button>

    <div id="ui-layer">
        <div class="control-panel">
            <div class="display-group">
                <div class="lcd-label">Credits</div>
                <div class="display"><div class="lcd-val" id="creditDisplay">0</div></div>
            </div>

            <div id="coinTray" class="panel-coin">
                <div id="coinDrag" class="coin">COIN</div>
            </div>
            <div id="coinSlotUI"></div>

            <div id="joystick-zone">
                <div id="joystick-stick"></div>
                <div id="joystick-knob"></div>
            </div>

            <button class="btn-action" id="dropBtn">DROP</button>

            <div class="display-group compact">
                <div class="lcd-label">Prizes</div>
                <div class="display"><div class="lcd-val" id="prizeDisplay">0</div></div>
            </div>

            <div class="display-group compact">
                <div class="lcd-label">Tickets</div>
                <div class="display"><div class="lcd-val" id="ticketDisplay">0</div></div>
            </div>

            <div class="display-group compact">
                <div class="lcd-label">Turns</div>
                <div class="display"><div class="lcd-val" id="turnDisplay">0</div></div>
            </div>
        </div>
    </div>

    <div id="catalog">
        <h3>Prize Catalog</h3>
    </div>
    <canvas></canvas>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'https://cdn.skypack.dev/cannon-es';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Audio Manager (Web Audio API)
        class AudioManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.motorOsc = null;
                this.motorGain = null;
                this.isPlayingMotor = false;
            }

            // Procedural Motor Sound (Whirring)
            startMotor(pitch = 200) {
                if (this.isPlayingMotor) return;
                this.isPlayingMotor = true;

                this.motorOsc = this.ctx.createOscillator();
                this.motorOsc.type = 'sawtooth';
                this.motorOsc.frequency.setValueAtTime(pitch, this.ctx.currentTime);

                this.motorGain = this.ctx.createGain();
                this.motorGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.motorGain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.1);

                // Filter to muffle it a bit like a motor
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;

                this.motorOsc.connect(filter);
                filter.connect(this.motorGain);
                this.motorGain.connect(this.masterGain);
                this.motorOsc.start();
            }

            stopMotor() {
                if (!this.isPlayingMotor) return;
                // "DJ Scratch" / Power down effect
                const now = this.ctx.currentTime;
                // Pitch drop
                this.motorOsc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                // Volume cut
                this.motorGain.gain.linearRampToValueAtTime(0, now + 0.3);

                this.motorOsc.stop(now + 0.3);
                this.isPlayingMotor = false;
            }

            playTone(freq, type, duration) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playWin() {
                // Arpeggio
                [440, 554, 659, 880].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.4), i * 150));
            }

            playLose() {
                [300, 250, 200].forEach((f, i) => setTimeout(() => this.playTone(f, 'triangle', 0.5), i * 300));
            }
        }
        const audio = new AudioManager();
        // User interaction required to start AudioContext usually, will handle on first input


        // UI Elements
        const creditDisplay = document.getElementById('creditDisplay');
        const prizeDisplay = document.getElementById('prizeDisplay');
        const ticketDisplay = document.getElementById('ticketDisplay');
        const turnDisplay = document.getElementById('turnDisplay');
        const catalogEl = document.getElementById('catalog');
        const catalogBtn = document.getElementById('toggleCatalog');
        const fadeOverlay = document.getElementById('fade-overlay');

        // Game State
        const testMode = new URLSearchParams(window.location.search).get('test') === '1';
        let prizeCount = 0, freeTurns = 0, turns = 5, credits = 0, tickets = 0;
        const catalog = [
            { name: 'Stuffed Bear', cost: 50 },
            { name: 'Toy Car', cost: 30 },
            { name: 'Keychain', cost: 15 }
        ];

        function updateUI() {
            if (creditDisplay) creditDisplay.textContent = credits;
            if (prizeDisplay) prizeDisplay.textContent = prizeCount;
            if (ticketDisplay) ticketDisplay.textContent = tickets;
            if (turnDisplay) turnDisplay.textContent = turns;
        }

        if (fadeOverlay) {
            requestAnimationFrame(() => {
                fadeOverlay.style.opacity = '0';
                setTimeout(() => { fadeOverlay.style.display = 'none'; }, 3200);
            });
        }

        // Populate catalog
        catalog.forEach(item => {
            const div = document.createElement('div');
            div.className = 'catalog-item';
            div.innerHTML = `${item.name} <span>${item.cost}</span>`;
            div.onclick = () => {
                if (tickets >= item.cost) {
                    tickets -= item.cost;
                    alert(`Redeemed ${item.name}!`);
                    updateUI();
                } else alert('Not enough tickets');
            };
            catalogEl.appendChild(div);
        });

        catalogBtn.onclick = () => {
            const isHidden = window.getComputedStyle(catalogEl).display === 'none';
            catalogEl.style.display = isHidden ? 'block' : 'none';
        };

        // Coin insertion (drag to slot only)
        function addCoin() {
            credits++;
            turns++;
            updateUI();
            audio.playTone(520, 'square', 0.12);
        }

        document.getElementById('insertCoin').onclick = () => {
            alert('Drag the coin to the slot to add credits!');
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(78, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 340, 780);
        const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = false;
        const MACHINE_SCALE = 84;
        const WORLD_SCALE = MACHINE_SCALE;

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.minDistance = 320;
        controls.maxDistance = 1400;


        // Lights
        // Lights
        scene.background = new THREE.Color(0x3a3a56);
        scene.fog = new THREE.FogExp2(0x3a3a56, 0.0014);

        const ambientLight = new THREE.AmbientLight(0xe0e0e0, 5.0);
        scene.add(ambientLight);
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x7a7a96, 3.0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 5.2);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = false;
        scene.add(dirLight);

        const textureLoader = new THREE.TextureLoader();
        const floorTexture = textureLoader.load('./textures/floor.png');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(10, 10);
        if (renderer.capabilities.getMaxAnisotropy) {
            floorTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        }

        const ceilingTexture = textureLoader.load('./textures/ceiling.png');
        ceilingTexture.wrapS = THREE.RepeatWrapping;
        ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(6, 6);
        if (renderer.capabilities.getMaxAnisotropy) {
            ceilingTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        }

        const roomFloorMat = new THREE.MeshStandardMaterial({ map: floorTexture, metalness: 0.1, roughness: 0.85 });
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(MACHINE_SCALE * 16, MACHINE_SCALE * 16),
            roomFloorMat
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -1.2;
        scene.add(floor);

        // Skybox
        const skyTex = ceilingTexture.clone();
        skyTex.wrapS = THREE.RepeatWrapping;
        skyTex.wrapT = THREE.RepeatWrapping;
        skyTex.repeat.set(4, 2);
        skyTex.needsUpdate = true;
        const skyMat = new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide, color: 0x222244 });
        const skySize = MACHINE_SCALE * 24;
        const skybox = new THREE.Mesh(new THREE.BoxGeometry(skySize, skySize, skySize), skyMat);
        skybox.position.set(0, skySize * 0.35, 0);
        scene.add(skybox);

        const roomMat = new THREE.MeshStandardMaterial({
            color: 0x303040,
            emissive: 0x151525,
            emissiveIntensity: 0.25,
            transparent: true,
            opacity: 0.35,
            roughness: 0.85,
            metalness: 0.05,
            side: THREE.DoubleSide
        });
        const roomSize = MACHINE_SCALE * 16;
        const roomHeight = MACHINE_SCALE * 10;
        const roomWallGeo = new THREE.PlaneGeometry(roomSize, roomHeight);
        const roomHalf = roomSize / 2;
        const roomWallY = roomHeight / 2;
        const roomBack = new THREE.Mesh(roomWallGeo, roomMat);
        roomBack.position.set(0, roomWallY, -roomHalf);
        scene.add(roomBack);
        const roomFront = new THREE.Mesh(roomWallGeo, roomMat);
        roomFront.position.set(0, roomWallY, roomHalf);
        roomFront.rotation.y = Math.PI;
        scene.add(roomFront);
        const roomLeft = new THREE.Mesh(roomWallGeo, roomMat);
        roomLeft.position.set(-roomHalf, roomWallY, 0);
        roomLeft.rotation.y = Math.PI / 2;
        scene.add(roomLeft);
        const roomRight = new THREE.Mesh(roomWallGeo, roomMat);
        roomRight.position.set(roomHalf, roomWallY, 0);
        roomRight.rotation.y = -Math.PI / 2;
        scene.add(roomRight);
        const roomCeilMat = new THREE.MeshStandardMaterial({
            map: ceilingTexture,
            roughness: 0.85,
            metalness: 0.05,
            emissive: 0x202038,
            emissiveIntensity: 0.2,
            side: THREE.DoubleSide
        });
        const roomCeil = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomCeilMat);
        roomCeil.position.set(0, roomHeight, 0);
        roomCeil.rotation.x = Math.PI / 2;
        scene.add(roomCeil);

        const dustCount = 160;
        const dustPositions = new Float32Array(dustCount * 3);
        for (let i = 0; i < dustCount; i++) {
            dustPositions[i * 3] = (Math.random() - 0.5) * 160;
            dustPositions[i * 3 + 1] = 10 + Math.random() * 70;
            dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 160;
        }
        const dustGeo = new THREE.BufferGeometry();
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
        const dustMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0.45, depthWrite: false });
        const dust = new THREE.Points(dustGeo, dustMat);
        scene.add(dust);

        // Arcade Cabinet Internal SpotLight
        const spotLight = new THREE.SpotLight(0xffffff, 14.5);
        spotLight.position.set(0, 230, 60);
        spotLight.angle = Math.PI / 3.9;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 980;
        spotLight.target.position.set(0, 0, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        const cabinetFill = new THREE.PointLight(0xffffff, 4.6, 560);
        cabinetFill.position.set(0, 120, 44);
        scene.add(cabinetFill);

        const cabinetFillLow = new THREE.PointLight(0x9bd0ff, 3.8, 520);
        cabinetFillLow.position.set(0, 64, -36);
        scene.add(cabinetFillLow);

        const neonCyan = new THREE.PointLight(0x00ffff, 4.4, 1200);
        neonCyan.position.set(250, 220, 230);
        scene.add(neonCyan);

        const neonMagenta = new THREE.PointLight(0xff33cc, 4.1, 1100);
        neonMagenta.position.set(-250, 210, -230);
        scene.add(neonMagenta);

        const overhead = new THREE.PointLight(0xffffff, 5.6, 2000);
        overhead.position.set(0, 440, 0);
        scene.add(overhead);

        const rimWarm = new THREE.PointLight(0xffaa88, 3.4, 980);
        rimWarm.position.set(-340, 200, 340);
        scene.add(rimWarm);

        const rimCool = new THREE.PointLight(0x88ccff, 3.4, 980);
        rimCool.position.set(340, 210, -340);
        scene.add(rimCool);

        // Light Manager
        class LightManager {
            constructor() {
                this.mode = 'IDLE'; // IDLE, WIN, LOSE, PLAY
                this.timer = 0;
                this.leds = [];
            }

            addLed(mesh) { this.leds.push(mesh); }

            update(dt) {
                this.timer += dt;
                const t = this.timer;

                this.leds.forEach((led, i) => {
                    const mat = led.material;
                    if (this.mode === 'IDLE') {
                        // Rainbow Wave
                        const hue = (t * 0.2 + i * 0.1) % 1;
                        mat.color.setHSL(hue, 1, 0.5);
                        mat.emissive.setHSL(hue, 1, 0.5);
                    } else if (this.mode === 'PLAY') {
                        mat.color.setHex(0xffaa00);
                        mat.emissive.setHex(0xffaa00);
                        mat.emissiveIntensity = 1 + Math.sin(t * 10) * 0.5;
                    } else if (this.mode === 'WIN') {
                        // Green Strobe
                        const on = Math.floor(t * 20) % 2 === 0;
                        mat.color.setHex(on ? 0x00ff00 : 0x000000);
                        mat.emissive.setHex(on ? 0x00ff00 : 0x000000);
                        mat.emissiveIntensity = 2;
                    } else if (this.mode === 'LOSE') {
                        // Slow Blue Pulse
                        const val = 0.5 + Math.sin(t * 2) * 0.5;
                        mat.color.setHex(0x0000ff);
                        mat.emissive.setHex(0x0000ff);
                        mat.emissiveIntensity = val;
                    }
                });
            }

            setMode(m) { this.mode = m; this.timer = 0; }
        }
        const lights = new LightManager();
        const baseAmbientIntensity = ambientLight.intensity;
        const baseDirIntensity = dirLight.intensity;
        const baseHemiIntensity = hemiLight.intensity;


        // Physics
        const world = new CANNON.World();
        world.gravity.set(0, -9.82 * WORLD_SCALE, 0);
        world.allowSleep = true;
        world.broadphase = new CANNON.NaiveBroadphase();
        world.defaultContactMaterial.friction = 0.5;
        world.defaultContactMaterial.restitution = 0.2;
        const physicsBodies = new Map();
        const physicsMeshes = [];
        const floorMaterial = new CANNON.Material('floor');
        const objectMaterial = new CANNON.Material('object');
        world.addContactMaterial(new CANNON.ContactMaterial(floorMaterial, objectMaterial, {
            friction: 0.6,
            restitution: 0.15
        }));

        // Machine Base (with Hole)
        // Floor pieces to create a hole at bottom-left (-x, +z)
        const machine = new THREE.Group();
        scene.add(machine);
        machine.scale.set(MACHINE_SCALE, MACHINE_SCALE, MACHINE_SCALE);
        let gantryBridge;
        let gantryCarriage;
        let ropeMesh;
        let coilMesh;
        let dragChainMesh;
        const ROOF_Y = 6;
        const CLAW_TOP_Y = 5.5;
        const FLOOR_Y = 2.4;
        const FLOOR_THICKNESS = 0.5;
        const FLOOR_TOP_Y = FLOOR_Y + FLOOR_THICKNESS / 2;
        const CLAW_BOTTOM_Y = FLOOR_TOP_Y - 0.05;
        const SPAWN_BOUNDS = { minX: -4.6, maxX: 4.6, minZ: -4.6, maxZ: 4.6 };
        const PRIZE_WALL_HEIGHT = 3.4;
        const PRIZE_WALL_THICKNESS = 0.08;
        const PRIZE_WALL_Y = FLOOR_TOP_Y + PRIZE_WALL_HEIGHT / 2;
        const interiorLight = new THREE.PointLight(0xffffff, 4.2, 260);
        interiorLight.position.set(0, FLOOR_TOP_Y + 1.6, 0);
        machine.add(interiorLight);
        const interiorTopLight = new THREE.PointLight(0xffffff, 5.6, 320);
        interiorTopLight.position.set(0, ROOF_Y - 0.2, 0);
        machine.add(interiorTopLight);
        const interiorFrontLight = new THREE.PointLight(0xfff2dd, 3.6, 220);
        interiorFrontLight.position.set(0, FLOOR_TOP_Y + 1.2, 3.1);
        machine.add(interiorFrontLight);

        const baseMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.3, roughness: 0.7 });
        const interiorFloorTex = floorTexture.clone();
        interiorFloorTex.repeat.set(2.2, 2.2);
        interiorFloorTex.anisotropy = floorTexture.anisotropy || 1;
        interiorFloorTex.needsUpdate = true;
        const interiorFloorMat = new THREE.MeshStandardMaterial({ map: interiorFloorTex, metalness: 0.05, roughness: 0.85 });
        const interiorCeilTex = ceilingTexture.clone();
        interiorCeilTex.repeat.set(1.8, 1.8);
        interiorCeilTex.anisotropy = ceilingTexture.anisotropy || 1;
        interiorCeilTex.needsUpdate = true;
        const interiorCeilMat = new THREE.MeshStandardMaterial({
            map: interiorCeilTex,
            metalness: 0.05,
            roughness: 0.9,
            emissive: 0x242424,
            emissiveIntensity: 0.25
        });

        // Floor Parts (Hole at corner approx -2 to -4 X, 2 to 4 Z)
        // Main floor right
        const f1 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 8), interiorFloorMat);
        f1.position.set(2, FLOOR_Y, 0);
        machine.add(f1);

        // Floor part top-left
        const f2 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), interiorFloorMat);
        f2.position.set(-2, FLOOR_Y, -2);
        machine.add(f2);

        // Chute "Hole" visual (black box below)
        const hole = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.2, 3.8), new THREE.MeshBasicMaterial({ color: 0x000000 }));
        hole.position.set(-2, FLOOR_Y - 0.35, 2);
        machine.add(hole);

        function toWorld(v) {
            return new CANNON.Vec3(v.x * WORLD_SCALE, v.y * WORLD_SCALE, v.z * WORLD_SCALE);
        }

        function addStaticBox(halfExtents, position, material) {
            const body = new CANNON.Body({ mass: 0, material });
            const scaledHalf = new CANNON.Vec3(halfExtents.x * WORLD_SCALE, halfExtents.y * WORLD_SCALE, halfExtents.z * WORLD_SCALE);
            body.addShape(new CANNON.Box(scaledHalf));
            const worldPos = toWorld(position);
            body.position.set(worldPos.x, worldPos.y, worldPos.z);
            world.addBody(body);
            return body;
        }

        function addDynamicBody(mesh, shape, mass = 1) {
            const body = new CANNON.Body({ mass, material: objectMaterial });
            body.addShape(shape);
            const worldPos = toWorld(mesh.position);
            body.position.set(worldPos.x, worldPos.y, worldPos.z);
            body.linearDamping = 0.2;
            body.angularDamping = 0.3;
            world.addBody(body);
            physicsBodies.set(mesh, body);
            physicsMeshes.push(mesh);
            return body;
        }

        function removePhysicsForMesh(mesh) {
            const body = physicsBodies.get(mesh);
            if (body) {
                world.removeBody(body);
                physicsBodies.delete(mesh);
                const idx = physicsMeshes.indexOf(mesh);
                if (idx !== -1) physicsMeshes.splice(idx, 1);
            }
        }

        // Physics floor pieces (match f1/f2 geometry)
        addStaticBox(new CANNON.Vec3(2, FLOOR_THICKNESS / 2, 4), new CANNON.Vec3(2, FLOOR_Y, 0), floorMaterial);
        addStaticBox(new CANNON.Vec3(2, FLOOR_THICKNESS / 2, 2), new CANNON.Vec3(-2, FLOOR_Y, -2), floorMaterial);

        // Physics walls (prize area)
        addStaticBox(new CANNON.Vec3(4.4, PRIZE_WALL_HEIGHT / 2, PRIZE_WALL_THICKNESS / 2), new CANNON.Vec3(0, PRIZE_WALL_Y, 4.4), floorMaterial);
        addStaticBox(new CANNON.Vec3(4.4, PRIZE_WALL_HEIGHT / 2, PRIZE_WALL_THICKNESS / 2), new CANNON.Vec3(0, PRIZE_WALL_Y, -4.4), floorMaterial);
        addStaticBox(new CANNON.Vec3(PRIZE_WALL_THICKNESS / 2, PRIZE_WALL_HEIGHT / 2, 4.4), new CANNON.Vec3(4.4, PRIZE_WALL_Y, 0), floorMaterial);
        addStaticBox(new CANNON.Vec3(PRIZE_WALL_THICKNESS / 2, PRIZE_WALL_HEIGHT / 2, 4.4), new CANNON.Vec3(-4.4, PRIZE_WALL_Y, 0), floorMaterial);

        const prizeGlassMat = new THREE.MeshStandardMaterial({ color: 0xddeeff, transparent: true, opacity: 0.22, side: THREE.DoubleSide });
        const prizeWallLong = new THREE.BoxGeometry(8.8, PRIZE_WALL_HEIGHT, PRIZE_WALL_THICKNESS);
        const prizeWallShort = new THREE.BoxGeometry(PRIZE_WALL_THICKNESS, PRIZE_WALL_HEIGHT, 8.8);
        const frontWall = new THREE.Mesh(prizeWallLong, prizeGlassMat);
        frontWall.position.set(0, PRIZE_WALL_Y, 4.4);
        machine.add(frontWall);
        const backWall = new THREE.Mesh(prizeWallLong, prizeGlassMat);
        backWall.position.set(0, PRIZE_WALL_Y, -4.4);
        machine.add(backWall);
        const leftWall = new THREE.Mesh(prizeWallShort, prizeGlassMat);
        leftWall.position.set(-4.4, PRIZE_WALL_Y, 0);
        machine.add(leftWall);
        const rightWall = new THREE.Mesh(prizeWallShort, prizeGlassMat);
        rightWall.position.set(4.4, PRIZE_WALL_Y, 0);
        machine.add(rightWall);

        // Machine glass walls removed; room walls now define the environment.
        const top = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), interiorCeilMat);
        top.position.y = ROOF_Y;
        machine.add(top);

        const neonStripMat = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 1.5,
            metalness: 0.2,
            roughness: 0.4
        });
        const stripLong = new THREE.BoxGeometry(8.2, 0.1, 0.1);
        const stripShort = new THREE.BoxGeometry(0.1, 0.1, 8.2);
        [
            [0, 0.55, 4.05, stripLong],
            [0, 0.55, -4.05, stripLong],
            [4.05, 0.55, 0, stripShort],
            [-4.05, 0.55, 0, stripShort]
        ].forEach(([x, y, z, geo]) => {
            const strip = new THREE.Mesh(geo, neonStripMat);
            strip.position.set(x, y, z);
            machine.add(strip);
        });

        // LEDs
        // LEDs
        const ledMat = new THREE.MeshStandardMaterial({ emissive: 0x00ffaa, emissiveIntensity: 1.5, color: 0x003300 });
        const ledGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8); // Height reduced 8->6
        const leds = [[-4, 3, -4], [4, 3, -4], [-4, 3, 4], [4, 3, 4]].map(pos => { // Y pos 4->3
            const m = new THREE.Mesh(ledGeo, ledMat.clone()); // Clone for individual control
            m.position.set(...pos);
            // Vertical by default (Cylinder is Y-axis aligned)
            machine.add(m);
            lights.addLed(m);
            return m;
        });



        // Chute (aligned with hole at -2, 2 in machine coordinates)
        const chuteBaseMat = new THREE.MeshStandardMaterial({ color: 0xffcc33, metalness: 0.2, roughness: 0.6 });
        const chuteGlowMat = new THREE.MeshStandardMaterial({
            color: 0xffee88,
            emissive: 0xffcc55,
            emissiveIntensity: 1.2,
            metalness: 0.1,
            roughness: 0.3
        });
        const chuteBase = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.14, 1.0), chuteBaseMat);
        chuteBase.position.set(-2, FLOOR_TOP_Y + 0.06, 2);
        machine.add(chuteBase);
        const chuteRim = new THREE.Mesh(new THREE.BoxGeometry(1.16, 0.05, 1.16), chuteGlowMat);
        chuteRim.position.set(-2, FLOOR_TOP_Y + 0.12, 2);
        machine.add(chuteRim);

        // Machine base (bottom enclosure)
        const baseMatDark = new THREE.MeshStandardMaterial({ color: 0x1b1b22, metalness: 0.2, roughness: 0.8 });
        const baseHeight = 2.2;
        const base = new THREE.Mesh(new THREE.BoxGeometry(8.4, baseHeight, 8.4), baseMatDark);
        base.position.set(0, FLOOR_Y - baseHeight / 2 - 0.15, 0);
        machine.add(base);

        // Coin slot on front face
        const slotMat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x222222, emissiveIntensity: 0.8 });
        const slot = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.22, 0.08), slotMat);
        slot.position.set(0, FLOOR_Y - 0.9, 4.3);
        machine.add(slot);

        const gantryMat = new THREE.MeshStandardMaterial({ color: 0x3b3e4a, metalness: 0.5, roughness: 0.4 });
        gantryBridge = new THREE.Group();
        const bridgeX = new THREE.Mesh(new THREE.BoxGeometry(8.8, 0.18, 0.6), gantryMat);
        bridgeX.position.set(0, ROOF_Y + 0.25, 0);
        const bridgeZ = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.18, 8.8), gantryMat);
        bridgeZ.position.set(0, ROOF_Y + 0.25, 0);
        gantryBridge.add(bridgeX, bridgeZ);
        machine.add(gantryBridge);

        gantryCarriage = new THREE.Group();
        const carriageBody = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.35, 1.4), gantryMat);
        carriageBody.position.set(0, 0, 0);
        gantryCarriage.add(carriageBody);
        machine.add(gantryCarriage);

        // Cabinet pillars + glass shell (visual only)
        const baseTopY = FLOOR_Y - 0.15;
        const cabinetHeight = Math.max(3.2, ROOF_Y - baseTopY + 0.2);
        const cabinetMidY = baseTopY + cabinetHeight / 2;
        const pillarMat = new THREE.MeshStandardMaterial({ color: 0xffcc33, metalness: 0.3, roughness: 0.4 });
        const pillarGeo = new THREE.BoxGeometry(0.28, cabinetHeight, 0.28);
        [
            [-4.35, cabinetMidY, -4.35],
            [4.35, cabinetMidY, -4.35],
            [-4.35, cabinetMidY, 4.35],
            [4.35, cabinetMidY, 4.35]
        ].forEach((pos) => {
            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
            pillar.position.set(pos[0], pos[1], pos[2]);
            machine.add(pillar);
        });

        const cabinetGlassMat = new THREE.MeshStandardMaterial({
            color: 0xd7e7ff,
            transparent: true,
            opacity: 0.22,
            roughness: 0.2,
            metalness: 0.05,
            side: THREE.DoubleSide
        });
        const glassW = 8.6;
        const glassH = cabinetHeight;
        const glassPanel = new THREE.PlaneGeometry(glassW, glassH);
        const glassSide = new THREE.PlaneGeometry(glassW, glassH);
        const frontGlass = new THREE.Mesh(glassPanel, cabinetGlassMat);
        frontGlass.position.set(0, cabinetMidY, 4.5);
        machine.add(frontGlass);
        const backGlass = new THREE.Mesh(glassPanel, cabinetGlassMat);
        backGlass.position.set(0, cabinetMidY, -4.5);
        backGlass.rotation.y = Math.PI;
        machine.add(backGlass);
        const leftGlass = new THREE.Mesh(glassSide, cabinetGlassMat);
        leftGlass.position.set(-4.5, cabinetMidY, 0);
        leftGlass.rotation.y = Math.PI / 2;
        machine.add(leftGlass);
        const rightGlass = new THREE.Mesh(glassSide, cabinetGlassMat);
        rightGlass.position.set(4.5, cabinetMidY, 0);
        rightGlass.rotation.y = -Math.PI / 2;
        machine.add(rightGlass);

        const marqueeMat = new THREE.MeshStandardMaterial({
            color: 0xb21c2d,
            emissive: 0xff7744,
            emissiveIntensity: 0.8,
            roughness: 0.4,
            metalness: 0.2
        });
        const marqueeBox = new THREE.Mesh(new THREE.BoxGeometry(8.4, 0.6, 0.6), marqueeMat);
        marqueeBox.position.set(0, ROOF_Y + 0.5, 4.2);
        machine.add(marqueeBox);

        const WIGGLE_STIFFNESS = 0.015;
        const WIGGLE_DAMPING = 0.98;
        const clawTarget = new THREE.Vector3(0, 0, 0);
        const clawPos = new THREE.Vector3(0, 0, 0);
        const clawWiggleVel = new THREE.Vector3(0, 0, 0);

        // Claw
        const clawGroup = new THREE.Group();
        // Pivot group for physics wiggle
        const clawPivot = new THREE.Group();
        clawGroup.add(clawPivot);
        clawGroup.position.set(0, CLAW_TOP_Y, 0); // Lower start pos
        machine.add(clawGroup);
        clawTarget.set(clawGroup.position.x, 0, clawGroup.position.z);
        clawPos.set(clawGroup.position.x, 0, clawGroup.position.z);

        const clawLight = new THREE.PointLight(0xffffff, 3.4, 240);
        clawLight.position.set(0, -0.6, 0);
        clawGroup.add(clawLight);

        const ropeContainer = new THREE.Group();
        const ropeGeo = new THREE.CylinderGeometry(0.04, 0.04, 1);
        ropeGeo.rotateX(-Math.PI / 2);
        ropeGeo.translate(0, 0, 0.5);
        const ropeBody = new THREE.Mesh(ropeGeo, new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }));
        ropeContainer.add(ropeBody);
        ropeMesh = ropeContainer;
        machine.add(ropeMesh);

        class HelixCurve extends THREE.Curve {
            getPoint(t) {
                const loops = 10;
                const angle = t * Math.PI * 2 * loops;
                const radius = 0.25;
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                const y = -t * 3.2;
                return new THREE.Vector3(x, y, z);
            }
        }
        const coilPath = new HelixCurve();
        const coilGeo = new THREE.TubeGeometry(coilPath, 96, 0.06, 6, false);
        coilGeo.rotateX(-Math.PI / 2);
        coilGeo.translate(0, 0, 1.6);
        const coilBody = new THREE.Mesh(coilGeo, new THREE.MeshStandardMaterial({ color: 0x141414, roughness: 0.9 }));
        const coilContainer = new THREE.Group();
        coilContainer.add(coilBody);
        coilMesh = coilContainer;
        machine.add(coilMesh);

        const chainPath = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 0)
        ]);
        const chainGeo = new THREE.TubeGeometry(chainPath, 12, 0.08, 4, false);
        dragChainMesh = new THREE.Mesh(chainGeo, new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 }));
        machine.add(dragChainMesh);

        // Confetti for win feedback
        const confettiCount = 220;
        const confettiPositions = new Float32Array(confettiCount * 3);
        const confettiVel = new Float32Array(confettiCount * 3);
        const confettiColors = new Float32Array(confettiCount * 3);
        const confettiGeo = new THREE.BufferGeometry();
        confettiGeo.setAttribute('position', new THREE.BufferAttribute(confettiPositions, 3));
        confettiGeo.setAttribute('color', new THREE.BufferAttribute(confettiColors, 3));
        const confettiMat = new THREE.PointsMaterial({ size: 0.18, vertexColors: true, transparent: true, opacity: 0.95 });
        const confetti = new THREE.Points(confettiGeo, confettiMat);
        confetti.visible = false;
        machine.add(confetti);
        let confettiLife = 0;

        function spawnConfetti(origin) {
            for (let i = 0; i < confettiCount; i++) {
                const idx = i * 3;
                confettiPositions[idx] = origin.x + (Math.random() - 0.5) * 2.8;
                confettiPositions[idx + 1] = origin.y + (Math.random() * 2.2);
                confettiPositions[idx + 2] = origin.z + (Math.random() - 0.5) * 2.8;
                confettiVel[idx] = (Math.random() - 0.5) * 3.5;
                confettiVel[idx + 1] = 3 + Math.random() * 3.5;
                confettiVel[idx + 2] = (Math.random() - 0.5) * 3.5;
                const color = new THREE.Color().setHSL(Math.random(), 0.9, 0.6);
                confettiColors[idx] = color.r;
                confettiColors[idx + 1] = color.g;
                confettiColors[idx + 2] = color.b;
            }
            confettiGeo.attributes.position.needsUpdate = true;
            confettiGeo.attributes.color.needsUpdate = true;
            confetti.visible = true;
            confettiLife = 2.4;
        }

        const dropButton = document.getElementById('dropBtn');
        let clawReady = false;
        dropButton.disabled = true;
        setTimeout(() => {
            updateCoinHome();
            resetCoin();
        }, 0);

        const winBanner = document.getElementById('winBanner');
        let winFlash = 0;

        // Custom Claw Model
        const fingers = [];
        const clawLoader = new GLTFLoader();
        clawLoader.load('./models/custom_claw.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(0.25, 0.25, 0.25); // Reduced 10x
            model.position.y = -0.2;
            clawPivot.add(model);

            // Find fingers and assign explicit axes by name/index
            model.traverse((child) => {
                if (child.name.startsWith('Finger')) {
                    fingers.push(child);
                }
            });
            // Sort to ensure 1, 2, 3 order
            fingers.sort((a, b) => a.name.localeCompare(b.name));

            fingers.forEach((child, i) => {
                // Assume 3 fingers at 0, 120, 240 degrees
                // If origins are 0,0,0, we force this distribution
                const angle = i * (Math.PI * 2 / 3);
                // Tangent vector for rotation axis (Perpendicular to radius)
                // Radius assumed closely aligned with angle. Tangent is (-sin, 0, cos)
                child.userData.axis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
                child.userData.currentAngle = 0;
            });
            clawReady = true;
            dropButton.disabled = false;
        }, undefined, (err) => console.error('Error loading claw:', err));



        // Balls & Prizes
        const balls = [];
        const prizeSpawnSpheres = [];

        function isHole(x, z) {
            return Math.hypot(x + 2, z - 2) < 1.4;
        }

        function getPrizeSpawnPosition(radius) {
            for (let attempt = 0; attempt < 50; attempt++) {
                const minX = SPAWN_BOUNDS.minX + radius;
                const maxX = SPAWN_BOUNDS.maxX - radius;
                const minZ = SPAWN_BOUNDS.minZ + radius;
                const maxZ = SPAWN_BOUNDS.maxZ - radius;
                if (minX >= maxX || minZ >= maxZ) break;
                const x = minX + Math.random() * (maxX - minX);
                const z = minZ + Math.random() * (maxZ - minZ);
                if (isHole(x, z)) continue;
                let ok = true;
                for (const s of prizeSpawnSpheres) {
                    if (Math.hypot(x - s.x, z - s.z) < radius + s.r + 0.2) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    prizeSpawnSpheres.push({ x, z, r: radius });
                    return { x, z };
                }
            }
            const fallback = {
                x: (SPAWN_BOUNDS.minX + SPAWN_BOUNDS.maxX) * 0.5,
                z: (SPAWN_BOUNDS.minZ + SPAWN_BOUNDS.maxZ) * 0.5
            };
            return fallback;
        }

        function getBallSpawnPosition() {
            for (let attempt = 0; attempt < 30; attempt++) {
                const radius = 0.2;
                const minX = SPAWN_BOUNDS.minX + radius;
                const maxX = SPAWN_BOUNDS.maxX - radius;
                const minZ = SPAWN_BOUNDS.minZ + radius;
                const maxZ = SPAWN_BOUNDS.maxZ - radius;
                const x = minX + Math.random() * (maxX - minX);
                const z = minZ + Math.random() * (maxZ - minZ);
                if (isHole(x, z)) continue;
                return { x, z };
            }
            return { x: 0, z: 0 };
        }

        for (let i = 0; i < 80; i++) {
            // 5x absolute scale (relative to original) means 0.5 local scale inside 10x machine
            const b = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 1, 0.5) })
            );
            const spawn = getBallSpawnPosition();
            b.position.set(spawn.x, FLOOR_TOP_Y + 0.15 + 0.05, spawn.z);
            b.userData.type = 'ball';
            b.userData.mass = 0.6;
            machine.add(b);
            balls.push(b);
            const ballShape = new CANNON.Sphere(0.15 * WORLD_SCALE);
            b.userData.bodyRadius = 0.15;
            addDynamicBody(b, ballShape, b.userData.mass);
        }

        const loader = new GLTFLoader();
        const prizes = [];
        // Updated model list based on directory contents
        const modelNames = ['bethany', 'caleb', 'connie', 'maia', 'donald', 'eric', 'kristen', 'kyle', 'rochelle', 'vickie'];

        modelNames.forEach(name => {
            // Using relative path assuming index.html is in root and models in models/
            loader.load(`./models/${name}.glb`, (gltf) => {
                const m = gltf.scene;
                // Scale 1/3 of 5.0 is approx 1.66
                // 5x absolute scale -> 0.5x local (Original 1.7 * 0.5 = 0.85)
                m.scale.set(PRIZE_SCALE, PRIZE_SCALE, PRIZE_SCALE);
                m.userData.baseScale = new THREE.Vector3(PRIZE_SCALE, PRIZE_SCALE, PRIZE_SCALE);
                m.userData.mass = 1.8;
                m.userData.type = 'prize';
                m.position.set(0, 0, 0);
                m.updateMatrixWorld(true);
                const bounds = new THREE.Box3().setFromObject(m);
                const sphere = new THREE.Sphere();
                bounds.getBoundingSphere(sphere);
                const visualRadius = Math.max(0.6, sphere.radius / MACHINE_SCALE);
                const physicsRadius = Math.min(1.1, Math.max(0.45, visualRadius * 0.32));
                const spawn = getPrizeSpawnPosition(physicsRadius);
                m.position.set(spawn.x, FLOOR_TOP_Y + physicsRadius + 0.08, spawn.z);
                machine.add(m);
                prizes.push(m);
                m.userData.bodyRadius = physicsRadius;
                m.userData.visualRadius = visualRadius;
                const prizeShape = new CANNON.Sphere(physicsRadius * WORLD_SCALE);
                addDynamicBody(m, prizeShape, m.userData.mass);
            }, undefined, (error) => {
                console.error(`Error loading ${name}.glb:`, error);
            });
        });

        // Game Logic & Controls
        const CLAW_STATES = {
            IDLE: 0,
            DROPPING: 1,
            WAIT_BOTTOM: 2,
            CLOSING: 3,
            WAIT_GRAB: 4,
            RISING: 5,
            MOVING_CORNER: 6,
            WIGGLE_STOP: 7,
            WAIT_DROP: 8,
            OPENING: 9,
            RETURNING: 10
        };

        let clawState = CLAW_STATES.IDLE;
        let stateTimer = 0;
        let grabbed = null;
        let grabbedBody = null;
        let clawVelocity = { x: 0, z: 0 };
        const keyState = { left: false, right: false, up: false, down: false };
        const CLAW_SPEED = 0.05;
        const LIMIT_X = 3.5;
        const LIMIT_Z = 3.5;
        const GRAB_RADIUS = 3.6;
        const GRAB_BASE_CHANCE = 0.85;
        const SLIP_BASE = 0.035;
        const SLIP_GRIP_PENALTY = 0.15;
        const SLIP_WEIGHT_PENALTY = 0.08;
        const WEIGHT_MAP = { ball: 0.8, prize: 1.2 };
        const PRIZE_SCALE = 4.25;
        let currentSlipRisk = 0;
        // Start open with negative angle
        let targetFingerAngle = -Math.PI / 4;

        // Joystick
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const joystickStick = document.getElementById('joystick-stick');
        const joystickManager = nipplejs.create({
            zone: joystickZone,
            mode: 'static',
            position: { left: '50%', top: '50%' },
            color: 'red'
        });

        // Coin drag/drop
        const coinDragEl = document.getElementById('coinDrag');
        const coinSlotUI = document.getElementById('coinSlotUI');
        let coinHome = null;
        let draggingCoin = false;
        let dragOffset = { x: 0, y: 0 };

        function updateCoinHome() {
            const rect = coinDragEl.getBoundingClientRect();
            coinHome = { x: rect.left, y: rect.top };
        }

        function resetCoin() {
            if (!coinHome) updateCoinHome();
            coinDragEl.style.position = 'fixed';
            coinDragEl.style.left = `${coinHome.x}px`;
            coinDragEl.style.top = `${coinHome.y}px`;
        }

        function checkCoinDrop(x, y) {
            const slotRect = coinSlotUI.getBoundingClientRect();
            const inside = x >= slotRect.left && x <= slotRect.right && y >= slotRect.top && y <= slotRect.bottom;
            if (inside) {
                addCoin();
                coinSlotUI.style.borderColor = 'rgba(255, 255, 255, 0.6)';
                setTimeout(() => coinSlotUI.style.borderColor = 'rgba(255, 255, 255, 0.25)', 250);
            }
            resetCoin();
        }

        coinDragEl.addEventListener('pointerdown', (e) => {
            draggingCoin = true;
            coinDragEl.setPointerCapture(e.pointerId);
            const rect = coinDragEl.getBoundingClientRect();
            dragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            coinDragEl.style.position = 'fixed';
            coinDragEl.style.left = `${rect.left}px`;
            coinDragEl.style.top = `${rect.top}px`;
        });

        window.addEventListener('pointermove', (e) => {
            if (!draggingCoin) return;
            coinDragEl.style.left = `${e.clientX - dragOffset.x}px`;
            coinDragEl.style.top = `${e.clientY - dragOffset.y}px`;
        });

        window.addEventListener('pointerup', (e) => {
            if (!draggingCoin) return;
            draggingCoin = false;
            checkCoinDrop(e.clientX, e.clientY);
        });

        joystickManager.on('move', (evt, data) => {
            if (!data.vector) return;
            if (clawState === CLAW_STATES.IDLE) {
                audio.ctx.resume(); // Ensure context is running
                clawVelocity.x = data.vector.x * CLAW_SPEED;
                clawVelocity.z = -data.vector.y * CLAW_SPEED;
                const speed = Math.hypot(clawVelocity.x, clawVelocity.z);
                audio.startMotor(200 + speed * 1000);
            }
            if (joystickKnob && joystickStick) {
                const maxDist = 36;
                const x = data.vector.x * maxDist;
                const y = data.vector.y * maxDist;
                joystickKnob.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                const length = Math.min(maxDist, Math.hypot(x, y));
                const angle = Math.atan2(y, x);
                joystickStick.style.width = `${length}px`;
                joystickStick.style.transform = `translate(0, -50%) rotate(${angle}rad)`;
            }
        });

        joystickManager.on('end', () => {
            clawVelocity.x = 0;
            clawVelocity.z = 0;
            audio.stopMotor();
            if (joystickKnob && joystickStick) {
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                joystickStick.style.width = '0px';
                joystickStick.style.transform = 'translate(0, -50%) rotate(0deg)';
            }
        });

        function applyKeyboardMovement() {
            if (clawState !== CLAW_STATES.IDLE) return;
            const x = (keyState.right ? 1 : 0) - (keyState.left ? 1 : 0);
            const z = (keyState.down ? 1 : 0) - (keyState.up ? 1 : 0);
            clawVelocity.x = x * CLAW_SPEED;
            clawVelocity.z = z * CLAW_SPEED;
            if (x !== 0 || z !== 0) {
                const speed = Math.hypot(clawVelocity.x, clawVelocity.z);
                audio.startMotor(200 + speed * 1000);
            } else {
                audio.stopMotor();
            }
        }

        function forcePrizeUnderClaw() {
            if (!testMode || prizes.length === 0) return;
            let closest = prizes[0];
            let best = clawGroup.position.distanceTo(prizes[0].position);
            for (let i = 1; i < prizes.length; i++) {
                const d = clawGroup.position.distanceTo(prizes[i].position);
                if (d < best) { best = d; closest = prizes[i]; }
            }
            const liftY = CLAW_BOTTOM_Y - (closest.userData.bodyRadius ?? 0.6);
            closest.position.set(clawGroup.position.x, Math.max(FLOOR_TOP_Y + 0.4, liftY), clawGroup.position.z);
            const body = physicsBodies.get(closest);
            if (body) {
                const worldPos = toWorld(closest.position);
                body.position.set(worldPos.x, worldPos.y, worldPos.z);
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                dropClaw();
                return;
            }
            if (e.key === 'b' || e.key === 'B') {
                forcePrizeUnderClaw();
                return;
            }
            if (e.key === 'ArrowLeft' || e.key === 'left' || e.key === 'a' || e.key === 'A') keyState.left = true;
            if (e.key === 'ArrowRight' || e.key === 'right' || e.key === 'd' || e.key === 'D') keyState.right = true;
            if (e.key === 'ArrowUp' || e.key === 'up' || e.key === 'w' || e.key === 'W') keyState.up = true;
            if (e.key === 'ArrowDown' || e.key === 'down' || e.key === 's' || e.key === 'S') keyState.down = true;
            applyKeyboardMovement();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'left' || e.key === 'a' || e.key === 'A') keyState.left = false;
            if (e.key === 'ArrowRight' || e.key === 'right' || e.key === 'd' || e.key === 'D') keyState.right = false;
            if (e.key === 'ArrowUp' || e.key === 'up' || e.key === 'w' || e.key === 'W') keyState.up = false;
            if (e.key === 'ArrowDown' || e.key === 'down' || e.key === 's' || e.key === 'S') keyState.down = false;
            applyKeyboardMovement();
        });

        // Drop Button
        dropButton.onclick = dropClaw;

        function setFingers(open) {
            targetFingerAngle = open ? -Math.PI / 2.5 : Math.PI / 4; // Wide open / Tight close
        }


        function dropClaw() {

            audio.ctx.resume();
            if (!clawReady) return;
            if (clawState === CLAW_STATES.IDLE && (turns > 0 || credits > 0)) {
                if (turns > 0) {
                    turns--;
                } else if (credits > 0) {
                    credits--;
                }

                clawState = CLAW_STATES.DROPPING;
                clawVelocity.x = 0;
                clawVelocity.z = 0;
                lights.setMode('PLAY');
                setFingers(true);
                updateUI();
                audio.startMotor(150); // Lower pitch for drop
            } else if (turns === 0 && credits === 0) {
                alert("Insert Coin!");
            }
        }

        function tryGrab() {
            let found = null;
            let best = Infinity;
            [...balls, ...prizes].forEach(obj => {
                const d = clawGroup.position.distanceTo(obj.position);
                if (d < GRAB_RADIUS && d < best) {
                    best = d;
                    found = obj;
                }
            });
            if (found) {
                const type = found.userData.type || 'prize';
                const weight = WEIGHT_MAP[type] || 1;
                const gripQuality = Math.max(0, 1 - (best / GRAB_RADIUS));
                const chance = testMode ? 1 : Math.min(1, GRAB_BASE_CHANCE * gripQuality * (1 / weight));
                if (Math.random() < chance) {
                    grabbed = found;
                    grabbed.userData.gripQuality = gripQuality;
                    grabbed.userData.weight = weight;
                    const radius = grabbed.userData.bodyRadius ?? 0.6;
                    const minCenterY = FLOOR_TOP_Y + radius;
                    const maxOffset = Math.max(0.3, clawGroup.position.y - minCenterY);
                    grabbed.userData.grabOffset = Math.min(radius + 0.3, maxOffset);
                    const body = physicsBodies.get(grabbed);
                    if (body) {
                        grabbedBody = body;
                        body.type = CANNON.Body.KINEMATIC;
                        body.mass = 0;
                        body.updateMassProperties();
                        body.velocity.set(0, 0, 0);
                        body.angularVelocity.set(0, 0, 0);
                        body.collisionResponse = false;
                    }
                    audio.playTone(400, 'sine', 0.1);
                }
            }
        }

        function releaseGrabbedToFloor() {
            if (!grabbed) return;
            const dropY = FLOOR_TOP_Y + (grabbed.userData.bodyRadius ?? 0.4);
            grabbed.position.set(clawGroup.position.x, dropY, clawGroup.position.z);
            const body = physicsBodies.get(grabbed);
            if (body) {
                body.type = CANNON.Body.DYNAMIC;
                body.mass = grabbed.userData.mass ?? 1;
                body.updateMassProperties();
                body.collisionResponse = true;
                const worldPos = toWorld(grabbed.position);
                body.position.set(worldPos.x, worldPos.y, worldPos.z);
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
            }
            grabbed = null;
            grabbedBody = null;
            currentSlipRisk = 0;
            audio.playTone(180, 'sawtooth', 0.2);
            lights.setMode('LOSE');
        }

        function maybeSlip(dt) {
            if (!grabbed || testMode) {
                currentSlipRisk = 0;
                return false;
            }
            const gripQuality = grabbed.userData.gripQuality ?? 0.5;
            const weight = grabbed.userData.weight ?? 1;
            const slipPerSecond = SLIP_BASE + (1 - gripQuality) * SLIP_GRIP_PENALTY + Math.max(0, weight - 1) * SLIP_WEIGHT_PENALTY;
            currentSlipRisk = slipPerSecond;
            const slipChance = 1 - Math.pow(1 - slipPerSecond, dt);
            if (Math.random() < slipChance) {
                releaseGrabbedToFloor();
                return true;
            }
            return false;
        }

        function checkWin() {
            if (!grabbed) return;
            // Dropped in hole?
            lights.setMode('WIN');
            audio.playWin();
            const wasBall = balls.includes(grabbed);
            if (wasBall) { freeTurns++; turns++; }
            else { prizeCount++; tickets += 10; }
            if (grabbed.parent) {
                grabbed.parent.remove(grabbed);
            } else {
                scene.remove(grabbed);
            }
            if (wasBall) {
                const idx = balls.indexOf(grabbed);
                if (idx !== -1) balls.splice(idx, 1);
            } else {
                const idx = prizes.indexOf(grabbed);
                if (idx !== -1) prizes.splice(idx, 1);
            }
            removePhysicsForMesh(grabbed);
            grabbed = null;
            grabbedBody = null;
            currentSlipRisk = 0;
            updateUI();
            winFlash = 1.4;
            if (winBanner) {
                winBanner.classList.remove('show');
                void winBanner.offsetWidth;
                winBanner.classList.add('show');
            }
            spawnConfetti(new THREE.Vector3(clawGroup.position.x, clawGroup.position.y + 0.6, clawGroup.position.z));
        }

        // Timer
        setInterval(() => {
            // Disabled auto-increment
        }, 60000);

        // Animation Loop
        const clock = new THREE.Clock();

        function update(dt) {
            lights.update(dt);
            dust.rotation.y += dt * 0.02;
            if (!grabbed) currentSlipRisk = 0;

            // Aim spotlight at the claw hang point
            if (spotLight && clawGroup) {
                const clawWorld = new THREE.Vector3();
                clawGroup.getWorldPosition(clawWorld);
                spotLight.target.position.copy(clawWorld);
                spotLight.target.updateMatrixWorld();
            }

            if (winFlash > 0) {
                winFlash = Math.max(0, winFlash - dt);
                const pulse = 0.5 + Math.sin((1 - winFlash) * 30) * 0.5;
                ambientLight.intensity = baseAmbientIntensity + winFlash * 2.2 + pulse * 0.6;
                dirLight.intensity = baseDirIntensity + winFlash * 2.0 + pulse * 0.5;
                hemiLight.intensity = baseHemiIntensity + winFlash * 1.6 + pulse * 0.4;
            } else {
                ambientLight.intensity = baseAmbientIntensity;
                dirLight.intensity = baseDirIntensity;
                hemiLight.intensity = baseHemiIntensity;
            }

            if (confettiLife > 0) {
                confettiLife -= dt;
                for (let i = 0; i < confettiCount; i++) {
                    const idx = i * 3;
                    confettiVel[idx + 1] -= 3.2 * dt;
                    confettiPositions[idx] += confettiVel[idx] * dt;
                    confettiPositions[idx + 1] += confettiVel[idx + 1] * dt;
                    confettiPositions[idx + 2] += confettiVel[idx + 2] * dt;
                }
                confettiGeo.attributes.position.needsUpdate = true;
                if (confettiLife <= 0) confetti.visible = false;
            }

            // Finger Animation
            fingers.forEach(f => {
                // Interpolate angle
                if (f.userData.currentAngle === undefined) f.userData.currentAngle = 0;
                f.userData.currentAngle += (targetFingerAngle - f.userData.currentAngle) * 5 * dt;

                // Rotate around calculated axis
                if (f.userData.axis) {
                    f.quaternion.setFromAxisAngle(f.userData.axis, f.userData.currentAngle);
                } else {
                    f.rotation.x = f.userData.currentAngle; // Fallback
                }
            });

            // State Machine
            switch (clawState) {
                case CLAW_STATES.IDLE:
                    // Joystick Movement
                    clawTarget.x += clawVelocity.x;
                    clawTarget.z += clawVelocity.z;

                    // Constraints
                    clawTarget.x = Math.max(-LIMIT_X, Math.min(LIMIT_X, clawTarget.x));
                    clawTarget.z = Math.max(-LIMIT_Z, Math.min(LIMIT_Z, clawTarget.z));
                    break;

                case CLAW_STATES.DROPPING:
                    clawGroup.position.y -= 1.5 * dt; // Slower drop
                    if (clawGroup.position.y <= CLAW_BOTTOM_Y) {
                        clawGroup.position.y = CLAW_BOTTOM_Y;
                        audio.stopMotor();
                        clawState = CLAW_STATES.WAIT_BOTTOM;
                        stateTimer = 0;
                    }
                    break;

                case CLAW_STATES.WAIT_BOTTOM:
                    stateTimer += dt;
                    if (stateTimer > 0.5) {
                        clawState = CLAW_STATES.CLOSING;
                    }
                    break;

                case CLAW_STATES.CLOSING:
                    if (!clawReady || fingers.length === 0) break;
                    setFingers(false); // Close
                    // Wait for fingers to visually close
                    // Check against target angle using userData
                    if (Math.abs(fingers[0].userData.currentAngle - targetFingerAngle) < 0.1) {
                        tryGrab();
                        clawState = CLAW_STATES.WAIT_GRAB;
                        stateTimer = 0;
                    }
                    break;

                case CLAW_STATES.WAIT_GRAB:
                    stateTimer += dt;
                    if (stateTimer > 1.0) {
                        clawState = CLAW_STATES.RISING;
                        audio.startMotor(250); // Higher pitch rise
                    }
                    break;

                case CLAW_STATES.RISING:
                    clawGroup.position.y += 1.5 * dt;
                    maybeSlip(dt);
                    if (clawGroup.position.y >= CLAW_TOP_Y) {
                        clawGroup.position.y = CLAW_TOP_Y;
                        audio.stopMotor();
                        clawState = CLAW_STATES.MOVING_CORNER;
                        audio.startMotor(200);
                    }
                    break;

                case CLAW_STATES.MOVING_CORNER:
                    // Move to (-2, 2) approx (Center of hole)
                    const targetX = -2;
                    const targetZ = 2; // Front left is +Z in this camera setup (camera at +Z positive)

                    const dx = targetX - clawTarget.x;
                    const dz = targetZ - clawTarget.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 0.001) {
                        const move = Math.min(dist, 4 * dt);
                        clawTarget.x += (dx / dist) * move;
                        clawTarget.z += (dz / dist) * move;
                        maybeSlip(dt);
                    }

                    const actualDist = Math.hypot(clawPos.x - targetX, clawPos.z - targetZ);
                    if (actualDist < 0.12) {
                        clawTarget.x = targetX;
                        clawTarget.z = targetZ;
                        audio.stopMotor(); // SCRATCH STOP
                        clawState = CLAW_STATES.WIGGLE_STOP;
                        stateTimer = 0;
                    }
                    break;

                case CLAW_STATES.WIGGLE_STOP:
                    stateTimer += dt;
                    if (stateTimer > 1.0) {
                        clawState = CLAW_STATES.OPENING;
                    }
                    break;

                case CLAW_STATES.OPENING:
                    setFingers(true);
                    if (grabbed) {
                        // Drop logic
                        checkWin();
                    } else {
                        // Empty drop
                        if (clawState !== CLAW_STATES.WAIT_DROP) {
                            audio.playTone(150, 'sawtooth', 0.3); // Fail sound
                            lights.setMode('LOSE');
                        }
                    }
                    clawState = CLAW_STATES.WAIT_DROP;
                    stateTimer = 0;
                    break;

                case CLAW_STATES.WAIT_DROP:
                    stateTimer += dt;
                    if (stateTimer > 1.0) {
                        clawState = CLAW_STATES.RETURNING;
                        audio.startMotor(200);
                    }
                    break;

                case CLAW_STATES.RETURNING:
                    // Return to 0,0
                    const rdx = 0 - clawTarget.x;
                    const rdz = 0 - clawTarget.z;
                    const rdist = Math.sqrt(rdx * rdx + rdz * rdz);

                    if (rdist > 0.001) {
                        const move = Math.min(rdist, 4 * dt);
                        clawTarget.x += (rdx / rdist) * move;
                        clawTarget.z += (rdz / rdist) * move;
                    }

                    const actualReturnDist = Math.hypot(clawPos.x, clawPos.z);
                    if (actualReturnDist < 0.12) {
                        clawTarget.x = 0;
                        clawTarget.z = 0;
                        audio.stopMotor();
                        clawState = CLAW_STATES.IDLE;
                        lights.setMode('IDLE');
                    }
                    break;
            }

            // Safety clamp to avoid overshoot in non-IDLE states
            clawTarget.x = Math.max(-LIMIT_X, Math.min(LIMIT_X, clawTarget.x));
            clawTarget.z = Math.max(-LIMIT_Z, Math.min(LIMIT_Z, clawTarget.z));

            const forceX = (clawTarget.x - clawPos.x) * WIGGLE_STIFFNESS;
            const forceZ = (clawTarget.z - clawPos.z) * WIGGLE_STIFFNESS;
            clawWiggleVel.x = (clawWiggleVel.x + forceX) * WIGGLE_DAMPING;
            clawWiggleVel.z = (clawWiggleVel.z + forceZ) * WIGGLE_DAMPING;
            clawPos.x += clawWiggleVel.x;
            clawPos.z += clawWiggleVel.z;
            clawPos.x = Math.max(-LIMIT_X, Math.min(LIMIT_X, clawPos.x));
            clawPos.z = Math.max(-LIMIT_Z, Math.min(LIMIT_Z, clawPos.z));

            clawGroup.position.x = clawPos.x;
            clawGroup.position.z = clawPos.z;
            clawGroup.rotation.z = -(clawTarget.x - clawPos.x) * 0.12;
            clawGroup.rotation.x = (clawTarget.z - clawPos.z) * 0.12;

            if (gantryCarriage) {
                gantryCarriage.position.set(clawTarget.x, ROOF_Y + 0.2, clawTarget.z);
            }

            if (ropeMesh && coilMesh) {
                const hookOffset = 0.7;
                const anchorVec = new THREE.Vector3(clawTarget.x, ROOF_Y + 0.2, clawTarget.z);
                const clawVec = new THREE.Vector3(clawGroup.position.x, clawGroup.position.y + hookOffset, clawGroup.position.z);
                ropeMesh.position.copy(anchorVec);
                ropeMesh.lookAt(clawVec);
                ropeMesh.scale.z = anchorVec.distanceTo(clawVec);

                const coilAnchor = anchorVec.clone().add(new THREE.Vector3(0.3, 0, 0.3));
                const coilClaw = clawVec.clone().add(new THREE.Vector3(0.3, 0, 0.3));
                coilMesh.position.copy(coilAnchor);
                coilMesh.lookAt(coilClaw);
                coilMesh.scale.set(1, 1, Math.max(0.2, coilAnchor.distanceTo(coilClaw) / 2.2));
            }

            if (dragChainMesh) {
                const start = new THREE.Vector3(-4.6, ROOF_Y + 0.3, clawTarget.z);
                const end = new THREE.Vector3(clawTarget.x, ROOF_Y + 0.3, clawTarget.z);
                const mid = start.clone().lerp(end, 0.5);
                mid.y += 1.2;
                dragChainMesh.geometry.dispose();
                const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
                dragChainMesh.geometry = new THREE.TubeGeometry(curve, 10, 0.08, 4, false);
            }

            // Grabbed Object Sync
            if (grabbed) {
                const offset = grabbed.userData.grabOffset ?? 1.0;
                grabbed.position.set(clawGroup.position.x, clawGroup.position.y - offset, clawGroup.position.z);
                if (grabbedBody) {
                    const worldPos = toWorld(grabbed.position);
                    grabbedBody.position.set(worldPos.x, worldPos.y, worldPos.z);
                }
            }

            world.step(1 / 60, dt, 3);
            physicsMeshes.forEach((mesh) => {
                if (mesh === grabbed) return;
                const body = physicsBodies.get(mesh);
                if (!body) return;
                mesh.position.set(body.position.x / WORLD_SCALE, body.position.y / WORLD_SCALE, body.position.z / WORLD_SCALE);
                mesh.quaternion.set(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);
            });

            prizes.forEach((p) => {
                if (!p.userData.baseScale) return;
                const base = p.userData.baseScale;
                const squish = new THREE.Vector3(base.x * 1.18, base.y * 0.68, base.z * 1.18);
                const target = p === grabbed ? squish : base;
                p.scale.lerp(target, 9 * dt);
            });

            controls.update();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            update(dt);
            render();
        }

        function resizeRenderer() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCoinHome();
            resetCoin();
        }

        window.addEventListener('resize', resizeRenderer);

        // Fullscreen toggle
        document.addEventListener('keydown', (e) => {
            if (e.key && e.key.toLowerCase() === 'f') {
                if (!document.fullscreenElement) {
                    renderer.domElement.requestFullscreen().catch(() => { });
                } else {
                    document.exitFullscreen().catch(() => { });
                }
            }
        });

        document.addEventListener('fullscreenchange', resizeRenderer);

        window.advanceTime = (ms) => {
            const step = 1 / 60;
            const steps = Math.max(1, Math.round((ms / 1000) / step));
            for (let i = 0; i < steps; i++) update(step);
            render();
        };

        function renderGameToText() {
            const payload = {
                mode: clawState,
                coords: 'x right, y up, z toward camera',
                clawReady,
                slipRisk: Number(currentSlipRisk.toFixed(3)),
                claw: {
                    x: Number(clawGroup.position.x.toFixed(2)),
                    y: Number(clawGroup.position.y.toFixed(2)),
                    z: Number(clawGroup.position.z.toFixed(2)),
                    grabbed: grabbed ? true : false,
                    grabQuality: grabbed ? Number((grabbed.userData.gripQuality ?? 0).toFixed(2)) : 0,
                    slipRisk: Number(currentSlipRisk.toFixed(3)),
                    clawReady
                },
                counts: {
                    prizeCount,
                    freeTurns,
                    turns,
                    credits,
                    tickets
                },
                lights: { mode: lights.mode },
                balls: balls.map(b => ({ x: Number(b.position.x.toFixed(2)), y: Number(b.position.y.toFixed(2)), z: Number(b.position.z.toFixed(2)) })),
                prizes: prizes.filter(p => p.parent).map(p => ({ x: Number(p.position.x.toFixed(2)), y: Number(p.position.y.toFixed(2)), z: Number(p.position.z.toFixed(2)) })),
                catalogVisible: window.getComputedStyle(catalogEl).display !== 'none',
                viewport: { w: window.innerWidth, h: window.innerHeight },
                fullscreen: !!document.fullscreenElement,
                testMode
            };
            return JSON.stringify(payload);
        }

        window.render_game_to_text = renderGameToText;

        animate();
        updateUI();
    </script>
</body>

</html>
