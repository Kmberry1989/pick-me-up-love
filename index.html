<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Claw Machine Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
            touch-action: none;
        }

        /* Fade In Overlay */
        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 9999;
            pointer-events: none;
            transition: opacity 3s ease-in-out;
            opacity: 1;
        }

        #ui-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 240px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 30px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: yellow;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 10000;
            pointer-events: none;
        }

        .control-panel {
            background: #2c3e50;
            padding: 20px 40px;
            border-radius: 20px;
            border: 4px solid #c0392b;
            display: flex;
            gap: 60px;
            /* Increased gap since coin button is gone */
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            align-items: center;
        }

        #joystick-zone {
            width: 120px;
            height: 120px;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 4px solid #7f8c8d;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }

        /* The visible stick connecting base to knob */
        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            height: 12px;
            background: linear-gradient(to bottom, #95a5a6, #7f8c8d);
            transform-origin: 0 50%;
            /* Pivot from center */
            pointer-events: none;
            z-index: 5;
            border-radius: 6px;
            width: 0px;
            /* Dynamic */
            transform: translate(0, -50%) rotate(0deg);
            /* Centered vertically */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        #joystick-knob {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #e74c3c, #c0392b);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            z-index: 10;
        }

        .btn-action {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            background: #e74c3c;
            color: white;
            font-size: 1.4rem;
            font-weight: 900;
            border: none;
            box-shadow: 0 8px 0 #962c22, 0 0 20px rgba(231, 76, 60, 0.4);
            cursor: pointer;
            transition: all 0.1s;
        }

        .btn-action:active {
            transform: translateY(8px);
            box-shadow: 0 0 0 #962c22;
        }

        .display-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .display {
            background: #000;
            color: #e74c3c;
            font-family: 'Courier New', monospace;
            padding: 10px 15px;
            border-radius: 5px;
            border: 2px solid #555;
            text-align: right;
            min-width: 80px;
        }

        .lcd-label {
            font-size: 11px;
            color: #95a5a6;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }

        .lcd-val {
            font-size: 28px;
            line-height: 1;
            text-shadow: 0 0 5px #e74c3c;
        }


        #collect-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 0 20px #e74c3c;
            display: none;
            pointer-events: auto;
            /* Enable clicking */
            text-align: center;
            cursor: pointer;
            /* Show hand cursor */
            z-index: 2000;
            /* Ensure on top */
        }

        #debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: yellow;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 10000;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="fade-overlay"></div>
    <div id="debug-overlay">Debug Info: Initializing...</div>

    <div id="collect-msg">PRIZE WON!<br><span style="font-size:20px">Click to Collect</span></div>

    <div id="ui-layer">
        <div class="control-panel">
            <div class="display-group">
                <div class="lcd-label">Credits</div>
                <div class="display">
                    <div class="lcd-val" id="creditDisplay">99</div>
                </div>
            </div>

            <!-- Joystick Container -->
            <div id="joystick-zone">
                <div id="joystick-stick"></div>
                <div id="joystick-knob"></div>
            </div>

            <button class="btn-action" id="dropBtn">DROP</button>
        </div>
    </div>

    <script>
        // --- Game Config (Slowed Down) ---
        const CONFIG = {
            cabinetWidth: 100,
            cabinetDepth: 100,
            floorY: -40,
            clawSpeed: 0.5,      // Reduced
            dropSpeed: 0.8,      // Reduced
            clawRestY: 60,
            winRatio: 0.3,
            wiggleStiffness: 0.015, // Softer sway
            wiggleDamping: 0.98
        };

        // --- Global State ---
        let state = {
            credits: 99,
            status: 'STARTUP', // STARTUP, IDLE, MOVING, DROPPING, GRABBING, LIFTING, RETURNING, RELEASING, WIN_SEQUENCE, RESETTING
            gantryX: -45,
            gantryZ: -40,
            clawY: CONFIG.clawRestY,
            clawOpen: true,
            heldPrize: null,
            clawPos: { x: -45, z: -40 },
            clawVel: { x: 0, z: 0 },
            cameraMode: 'GAME', // GAME, TRANSITION_TO_PRIZE, PRIZE_VIEW, TRANSITION_TO_GAME
            wonPrize: null
        };

        let playerInput = { up: false, down: false, left: false, right: false, analogX: 0, analogY: 0 };

        // --- Three.js Globals ---
        let scene, camera, renderer;
        let clawGroup, gantryBridge, gantryCarriage, ropeMesh, coilMesh, dragChainMesh;
        let prizes = [];
        let fingers = [];
        let dropTargetY = CONFIG.floorY;
        let ledStrips = [];
        let ledPointLights = [];
        let particles = []; // For confetti

        let loadedClawModel = null;
        const loadedPrizeModels = {};
        const prizeFiles = [
            'bethany.glb', 'caleb.glb', 'connie.glb', 'donald.glb', 'eric.glb',
            'kristen.glb', 'kyle.glb', 'maia.glb', 'rochelle.glb', 'vickie.glb'
        ];

        function debugLog(msg) {
            const el = document.getElementById('debug-overlay');
            if (el) el.innerHTML += '<br>' + msg;
            console.log(msg);
        }

        function loadAssets(onComplete) {
            if (typeof THREE === 'undefined') {
                debugLog("Error: THREE is undefined");
                return;
            }
            if (!THREE.GLTFLoader) {
                debugLog("Error: THREE.GLTFLoader is missing. Check internet/CDN.");
                return;
            }
            const loader = new THREE.GLTFLoader();
            let itemsToLoad = 1 + prizeFiles.length; // Claw + prizes
            let itemsLoaded = 0;

            function checkDone() {
                itemsLoaded++;
                debugLog(`Loaded ${itemsLoaded}/${itemsToLoad} assets`);
                if (itemsLoaded >= itemsToLoad) onComplete();
            }

            // Load Claw
            // Note: User says claw grabs nothing and hose not attached.
            // We need to find the "root" of the claw for the hose, and "fingers" for animation.
            loader.load('models/custom_claw.glb', (gltf) => {
                loadedClawModel = gltf.scene;
                loadedClawModel.scale.set(15, 15, 15); // Increased scale from 5 to 15 based on user report (might be too small)

                debugLog("Claw Loaded. Nodes:");
                loadedClawModel.traverse(c => {
                    // debugLog("- " + c.name + " (" + c.type + ")");
                    // Auto-detect fingers? 
                    // Looking for 3 objects that might be fingers.
                    if (c.name.toLowerCase().includes('finger') || c.name.toLowerCase().includes('arm')) {
                        // Likely a finger
                    }
                });
                checkDone();
            }, undefined, (err) => {
                debugLog("Error loading claw: " + err.message);
                checkDone();
            });

            // Load Prizes
            prizeFiles.forEach(file => {
                loader.load('models/prizes/' + file, (gltf) => {
                    loadedPrizeModels[file] = gltf.scene;
                    checkDone();
                }, undefined, (err) => {
                    debugLog("Error loading " + file + ": " + err.message);
                    checkDone();
                });
            });
        }


        // --- Marquee Globals ---
        let marqueeTexture, marqueeCtx;
        let marqueeState = {
            mode: 'SCROLL',
            offset: 0,
            phrases: [
                "STEP RIGHT UP AND TEST YOUR LUCK TODAY!",
                "FOCUS YOUR MIND, STEADY YOUR HAND, AND WIN.",
                "THE CLAW AWAITS YOUR COMMAND, BRAVE PLAYER.",
                "WILL YOU BE THE LEGENDARY WINNER WE SEEK?",
                "KEEP YOUR EYES ON THE PRIZE AND DON'T LET GO!"
            ],
            currentPhraseIndex: 0,
            overrideText: "",
            blinkVisible: true,
            lastBlinkTime: 0,
            eventEndTime: 0,
            fullTextString: "" // To store the joined string
        };

        // --- Sound Manager (Procedural Audio) ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; // Low volume default
                this.masterGain.connect(this.ctx.destination);

                this.motorOsc = null;
                this.motorGain = null;
                this.isMotorPlaying = false;
            }

            resume() {
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playBeep(freq = 440, type = 'sine', duration = 0.1) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playArcadeStart() {
                this.playBeep(660, 'square', 0.1);
                setTimeout(() => this.playBeep(880, 'square', 0.2), 100);
            }

            playMotor(playing) {
                if (playing && !this.isMotorPlaying) {
                    this.isMotorPlaying = true;
                    this.motorOsc = this.ctx.createOscillator();
                    this.motorGain = this.ctx.createGain();
                    this.motorOsc.type = 'sawtooth';
                    this.motorOsc.frequency.setValueAtTime(50, this.ctx.currentTime); // Low hum
                    this.motorGain.gain.setValueAtTime(0.05, this.ctx.currentTime);

                    // Filter to muffle it
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 200;

                    this.motorOsc.connect(filter);
                    filter.connect(this.motorGain);
                    this.motorGain.connect(this.masterGain);
                    this.motorOsc.start();
                } else if (!playing && this.isMotorPlaying) {
                    this.isMotorPlaying = false;
                    if (this.motorOsc) {
                        const stopTime = this.ctx.currentTime + 0.2;
                        this.motorGain.gain.linearRampToValueAtTime(0, stopTime);
                        this.motorOsc.stop(stopTime);
                        this.motorOsc = null;
                    }
                }
            }

            playWin() {
                // Arpeggio
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C Major
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playBeep(freq, 'triangle', 0.3), i * 150);
                });
                setTimeout(() => this.playApplause(), 600);
            }

            playApplause() {
                const duration = 2.0;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.5; // White noise
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();

                // Filter for "clapping" sound (bandpass)
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }
        }

        let soundManager;

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdae6f0); // Bright Pastel Blue
            scene.fog = new THREE.Fog(0xdae6f0, 300, 900); // Airy fog

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition(); // Set initial pos

            // Shimmer Light (Attached to Camera)
            const cameraLight = new THREE.PointLight(0xffffff, 0.6, 200);
            cameraLight.position.set(0, 20, 0);
            camera.add(cameraLight);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Increased to 0.8
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbbb, 0.8); // Brighter ground
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            const spotLight = new THREE.SpotLight(0xfffae0, 1.5);
            spotLight.position.set(0, 200, 100);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            scene.add(spotLight);

            const internalLight = new THREE.PointLight(0xffffff, 1.2, 200);
            internalLight.position.set(0, 85, 0);
            scene.add(internalLight);

            const ceilingPanel = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
            );
            ceilingPanel.rotation.x = Math.PI / 2;
            ceilingPanel.position.set(0, 89, 0);
            scene.add(ceilingPanel);

            setupMarquee();
            buildArcadeRoom(); // New function for environment
            buildCabinet();
            buildLEDs();
            buildGantry();
            spawnPrizes();

            soundManager = new SoundManager();
            window.addEventListener('click', () => {
                soundManager.resume();
            }, { once: true });

            window.addEventListener('keydown', () => {
                soundManager.resume();
            }, { once: true });

            window.addEventListener('resize', onResize, false);
            setupInputListeners();
            setupJoystick();
            setupMouseOrbit();
            updateCreditDisplay();

            // Fade In Logic
            setTimeout(() => {
                document.getElementById('fade-overlay').style.opacity = 0;
            }, 100);

            animate();
            window.focus();
        }

        function buildArcadeRoom() {
            // Light floor
            const floorGeo = new THREE.PlaneGeometry(1000, 1000);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0xeeeeee, // White/Light Grey
                roughness: 0.8,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = CONFIG.floorY - 110; // Lowered to reveal base
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls to enclose the space
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.BackSide });
            const roomGeo = new THREE.BoxGeometry(900, 600, 900);
            const room = new THREE.Mesh(roomGeo, wallMat);
            room.position.set(0, 280, 0);
            scene.add(room);

            // Neighboring Arcade Machines REMOVED per user request
            // (Code deleted to clean up scene)

            // Load Background Couch Prop
            const loader = new THREE.GLTFLoader();
            loader.load('models/props/couch.glb', (gltf) => {
                const couch = gltf.scene;
                couch.position.set(0, CONFIG.floorY, -200);
                couch.scale.set(40, 40, 40);
                couch.rotation.y = 0; // Face forward? Or back? Try 0 first

                couch.traverse((c) => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });
                scene.add(couch);
            }, undefined, (e) => {
                debugLog("Failed to load couch: " + e);
            });
        }

        function setupMarquee() {
            const canvas = document.createElement('canvas');
            canvas.width = 4096; // 4x 1024 for detail across 4 panels
            canvas.height = 256;
            marqueeCtx = canvas.getContext('2d');
            marqueeTexture = new THREE.CanvasTexture(canvas);
            marqueeTexture.wrapS = THREE.RepeatWrapping;
            marqueeTexture.wrapT = THREE.ClampToEdgeWrapping;

            // Build the full unified string once
            const separator = "          *** "; // Large gap
            marqueeState.fullTextString = marqueeState.phrases.join(separator) + separator;
        }

        function updateMarquee() {
            const ctx = marqueeCtx;
            const w = 4096;
            const h = 256;
            const time = Date.now();

            // Background
            const grd = ctx.createLinearGradient(0, 0, 0, h);
            if (state.status === 'STARTUP') {
                const hue = (time * 0.2) % 360;
                grd.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                grd.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);
            } else if (marqueeState.mode === 'WIN') {
                grd.addColorStop(0, "#f1c40f");
                grd.addColorStop(0.5, "#fff200");
                grd.addColorStop(1, "#f1c40f");
            } else if (marqueeState.mode === 'LOSS') {
                grd.addColorStop(0, "#c0392b");
                grd.addColorStop(0.5, "#e74c3c");
                grd.addColorStop(1, "#c0392b");
            } else {
                grd.addColorStop(0, "#ff9f43");
                grd.addColorStop(0.5, "#ffc048");
                grd.addColorStop(1, "#ff9f43");
            }
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, w, h);

            ctx.fillStyle = "rgba(0,0,0,0.1)";
            for (let i = 0; i < h; i += 4) ctx.fillRect(0, i, w, 2);

            // CHANGED: Using "Impact" font for taller look
            ctx.font = 'bold 180px "Impact", "Arial Narrow", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (state.status === 'STARTUP') {
                drawFancyText(ctx, "SYSTEM INITIALIZING...", w / 2, h / 2);
            } else {
                // Unified Scrolling for ALL modes (SCROLL, WIN, LOSS)
                ctx.textAlign = 'left';

                let speed = 2; // Default speed
                let text = marqueeState.fullTextString;

                if (marqueeState.mode === 'WIN' || marqueeState.mode === 'LOSS') {
                    // Check timeout
                    if (time > marqueeState.eventEndTime) {
                        marqueeState.mode = 'SCROLL';
                    } else {
                        speed = 6; // FAST SCROLL
                        // Construct repeated text for the event message
                        const msg = marqueeState.overrideText + "     ***     ";
                        // Repeat it enough to behave like the full string
                        text = msg.repeat(10);
                    }
                }

                marqueeState.offset += speed;
                const textWidth = ctx.measureText(text).width; // Approx for wrap logic
                // Note: measureText might be slow on huge strings, but simple wrap logic:
                // We'll just wrap based on a large arbitrary number or let it flow if we constructed a long enough string.
                // For the main scroll, fullTextString is long.

                // Better wrap logic for infinite scroll:
                // We need to draw the string at -offset.
                // If offset > single_repetition_width, reset offset.
                // But fullTextString is already likely long.
                // Let's stick to the previous simple wrap:
                if (marqueeState.offset > 4000) { // arbitrary reset point, or calculate actual width
                    marqueeState.offset = 0;
                }

                // Since we might have different texts, we need to ensure continuity. 
                // Getting exact width of "repeating unit" is best.
                // For SCROLL mode: unit is fullTextString (already repeated?). 
                // Actually fullTextString was joined. 

                // Let's simplify: Just draw the text at x and x + width.
                // We need the width of the *visible block* to loop it.

                let loopWidth = 0;
                if (marqueeState.mode === 'SCROLL') {
                    loopWidth = ctx.measureText(marqueeState.fullTextString).width;
                } else {
                    // For WIN/LOSS, we constructed a long string?
                    // Let's just use the override text + gap as the loop unit.
                    const unit = marqueeState.overrideText + "     ***     ";
                    loopWidth = ctx.measureText(unit).width;
                    text = unit.repeat(20); // Make it long enough to cover screen
                }

                if (marqueeState.offset > loopWidth) marqueeState.offset %= loopWidth;

                let x = -marqueeState.offset;
                drawFancyText(ctx, text, x, h / 2);
                drawFancyText(ctx, text, x + loopWidth * (text.length / (text.length / 20 || 1)), h / 2); // Fallback logic a bit complex here.

                // SIMPLER APPROACH:
                // Just draw "text" at x. If x + width < canvas_width, draw again at x + width.
                // But "text" needs to be the repeating unit.

                // Final robust approach for this block:
                let unitText = "";
                if (marqueeState.mode === 'SCROLL') unitText = marqueeState.fullTextString;
                else unitText = marqueeState.overrideText + "          ***          "; // Gap

                const unitWidth = ctx.measureText(unitText).width;
                if (marqueeState.offset > unitWidth) marqueeState.offset %= unitWidth;

                let drawX = -marqueeState.offset;
                while (drawX < w) {
                    drawFancyText(ctx, unitText, drawX, h / 2);
                    drawX += unitWidth;
                }
            }

            if (marqueeTexture) marqueeTexture.needsUpdate = true;
        }

        function drawFancyText(ctx, text, x, y) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillText(text, x + 8, y + 8);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, x, y);
        }

        function triggerEvent(type) {
            const wins = ["JACKPOT! YOU ARE A MASTER!", "LEGENDARY SKILL DETECTED!", "WINNER WINNER, CHICKEN DINNER!", "THE CLAW HAS CHOSEN YOU!"];
            const loss = ["SO CLOSE, YET SO FAR!", "BETTER LUCK NEXT TIME.", "OH NO! IT SLIPPED AWAY.", "KEEP TRYING, DON'T GIVE UP!"];
            marqueeState.mode = type;
            marqueeState.eventEndTime = Date.now() + 5000;
            if (type === 'WIN') {
                marqueeState.overrideText = wins[Math.floor(Math.random() * wins.length)];
                if (soundManager) soundManager.playWin();
            } else {
                marqueeState.overrideText = loss[Math.floor(Math.random() * loss.length)];
                if (soundManager) soundManager.playBeep(150, 'sawtooth', 0.5); // Sad beep
            }
        }

        function buildLEDs() {
            const positions = [
                { x: -44, z: -44, rot: Math.PI / 4 },
                { x: 44, z: -44, rot: -Math.PI / 4 },
                { x: -44, z: 44, rot: -Math.PI / 4 },
                { x: 44, z: 44, rot: Math.PI / 4 }
            ];
            const ledGeo = new THREE.BoxGeometry(2, 120, 1);
            positions.forEach((pos, index) => {
                const ledMat = new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0xff0000, emissiveIntensity: 2 });
                const strip = new THREE.Mesh(ledGeo, ledMat);
                strip.position.set(pos.x, 25, pos.z);
                strip.rotation.y = pos.rot;
                scene.add(strip);
                ledStrips.push(strip);
                const light = new THREE.PointLight(0xff0000, 0.4, 50);
                light.position.set(pos.x * 0.9, 25, pos.z * 0.9);
                scene.add(light);
                ledPointLights.push(light);
            });
        }

        // Helper to map UVs to a sub-section of the texture
        function mapUVs(geometry, minU, maxU) {
            const uvAttribute = geometry.attributes.uv;
            for (let i = 0; i < uvAttribute.count; i++) {
                const u = uvAttribute.getX(i);
                // Map 0..1 to minU..maxU
                const newU = minU + (u * (maxU - minU));
                uvAttribute.setX(i, newU);
            }
            uvAttribute.needsUpdate = true;
        }

        function buildCabinet() {
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transmission: 0.95, opacity: 0.1, transparent: true, roughness: 0.05, metalness: 0.1, clearcoat: 1.0, clearcoatRoughness: 0.0
            });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xff4757, roughness: 0.3, metalness: 0.4 });
            const chromeMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.1, metalness: 0.9 });
            const railMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.8, roughness: 0.2 });

            const floor = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cabinetWidth, 4, CONFIG.cabinetDepth), floorMat);
            floor.position.y = CONFIG.floorY; floor.receiveShadow = true; scene.add(floor);

            const ceiling = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cabinetWidth, 4, CONFIG.cabinetDepth), metalMat);
            ceiling.position.y = 90; scene.add(ceiling);

            const marquee = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cabinetWidth + 4, 16, CONFIG.cabinetDepth + 4), metalMat);
            marquee.position.y = 100; scene.add(marquee);

            // --- Marquee Panels with Unified UV Mapping ---
            const glowMat = new THREE.MeshBasicMaterial({ map: marqueeTexture });

            const frontGeo = new THREE.PlaneGeometry(90, 10);
            mapUVs(frontGeo, 0.50, 0.75);
            const frontGlow = new THREE.Mesh(frontGeo, glowMat);
            frontGlow.position.set(0, 100, 53);
            scene.add(frontGlow);

            const backGeo = new THREE.PlaneGeometry(90, 10);
            mapUVs(backGeo, 0.0, 0.25);
            const backGlow = new THREE.Mesh(backGeo, glowMat);
            backGlow.position.set(0, 100, -53);
            backGlow.rotation.y = Math.PI;
            scene.add(backGlow);

            const leftGeo = new THREE.PlaneGeometry(90, 10);
            mapUVs(leftGeo, 0.25, 0.50);
            const leftGlow = new THREE.Mesh(leftGeo, glowMat);
            leftGlow.position.set(-53, 100, 0);
            leftGlow.rotation.y = -Math.PI / 2;
            scene.add(leftGlow);

            const rightGeo = new THREE.PlaneGeometry(90, 10);
            mapUVs(rightGeo, 0.75, 1.00);
            const rightGlow = new THREE.Mesh(rightGeo, glowMat);
            rightGlow.position.set(53, 100, 0);
            rightGlow.rotation.y = Math.PI / 2;
            scene.add(rightGlow);

            // Pillars
            const pillarGeo = new THREE.BoxGeometry(4, 130, 4);
            const positions = [[-48, 25, -48], [48, 25, -48], [-48, 25, 48], [48, 25, 48]];
            positions.forEach(pos => {
                const p = new THREE.Mesh(pillarGeo, metalMat); p.position.set(...pos); scene.add(p);
                const cap = new THREE.Mesh(new THREE.BoxGeometry(6, 2, 6), chromeMat); cap.position.set(pos[0], 90, pos[2]); scene.add(cap);
                const base = new THREE.Mesh(new THREE.BoxGeometry(6, 2, 6), chromeMat); base.position.set(pos[0], CONFIG.floorY + 2, pos[2]); scene.add(base);
            });

            // Glass
            const backGlass = new THREE.Mesh(new THREE.PlaneGeometry(90, 130), glassMat); backGlass.position.set(0, 25, -48); scene.add(backGlass);
            const leftGlass = new THREE.Mesh(new THREE.PlaneGeometry(90, 130), glassMat); leftGlass.rotation.y = Math.PI / 2; leftGlass.position.set(-48, 25, 0); scene.add(leftGlass);
            const rightGlass = new THREE.Mesh(new THREE.PlaneGeometry(90, 130), glassMat); rightGlass.rotation.y = -Math.PI / 2; rightGlass.position.set(48, 25, 0); scene.add(rightGlass);
            const frontGlass = new THREE.Mesh(new THREE.PlaneGeometry(90, 130), glassMat); frontGlass.position.set(0, 25, 48); scene.add(frontGlass);

            const sideRailGeo = new THREE.CylinderGeometry(0.8, 0.8, CONFIG.cabinetDepth - 6, 12);
            sideRailGeo.rotateX(Math.PI / 2);
            const leftSideRail = new THREE.Mesh(sideRailGeo, railMat); leftSideRail.position.set(-49, 73.7, 0); scene.add(leftSideRail);
            const rightSideRail = new THREE.Mesh(sideRailGeo, railMat); rightSideRail.position.set(49, 73.7, 0); scene.add(rightSideRail);

            // Prize Chute & Retrieval Bin
            const chuteGroup = new THREE.Group();
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(32, 30, 2), wallMat); w1.position.z = -16;
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(32, 30, 2), wallMat); w2.position.z = 16;
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(2, 30, 32), wallMat); w3.position.x = 16;
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(2, 30, 32), wallMat); w4.position.x = -16;
            chuteGroup.add(w1, w2, w3, w4);
            const hole = new THREE.Mesh(new THREE.BoxGeometry(30, 2, 30), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            hole.position.y = -4; chuteGroup.add(hole);
            chuteGroup.position.set(-25, CONFIG.floorY + 7, 34); scene.add(chuteGroup);

            // Retrieval Box (Below the door)
            const retrievalBox = new THREE.Mesh(new THREE.BoxGeometry(30, 20, 30), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            retrievalBox.position.set(-25, CONFIG.floorY - 20, 40);
            scene.add(retrievalBox);

            const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(40, 30, 2), metalMat); doorFrame.position.set(0, CONFIG.floorY - 20, 50); scene.add(doorFrame);
            const doorFlap = new THREE.Mesh(new THREE.BoxGeometry(34, 24, 2), new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 }));
            doorFlap.position.set(0, CONFIG.floorY - 20, 51); doorFlap.rotation.x = -0.2; scene.add(doorFlap);

            // --- LOWER CABINET (Base) ---
            const baseMat = new THREE.MeshStandardMaterial({ color: 0xff4757, roughness: 0.4 }); // Match metal/accent color
            const baseBody = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.cabinetWidth, 100, CONFIG.cabinetDepth), baseMat);
            baseBody.position.set(0, CONFIG.floorY - 50, 0); // Extend down from floor
            scene.add(baseBody);

            // Control Panel Ledge
            const ledgeGeo = new THREE.BoxGeometry(CONFIG.cabinetWidth, 10, 30);
            const ledge = new THREE.Mesh(ledgeGeo, baseMat);
            ledge.position.set(0, CONFIG.floorY - 5, 60); // Protrude front
            // ledge.rotation.x = 0.1; // Slight tilt
            scene.add(ledge);

            // Coin Door Area
            const coinDoor = new THREE.Mesh(new THREE.PlaneGeometry(40, 50), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            coinDoor.position.set(0, CONFIG.floorY - 50, 50.1); // On front of base
            scene.add(coinDoor);

            // Coin Slots (Visual)
            const slotGeo = new THREE.PlaneGeometry(5, 8);
            const slotMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
            const s1 = new THREE.Mesh(slotGeo, slotMat); s1.position.set(-8, CONFIG.floorY - 45, 50.2); scene.add(s1);
            const s2 = new THREE.Mesh(slotGeo, slotMat); s2.position.set(8, CONFIG.floorY - 45, 50.2); scene.add(s2);

            // Feet
            const footGeo = new THREE.CylinderGeometry(5, 5, 10);
            const footMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const feetPos = [
                { x: -40, z: -40 }, { x: 40, z: -40 },
                { x: -40, z: 40 }, { x: 40, z: 40 }
            ];
            feetPos.forEach(p => {
                const foot = new THREE.Mesh(footGeo, footMat);
                foot.position.set(p.x, CONFIG.floorY - 105, p.z);
                scene.add(foot);
            });
        }

        function buildGantry() {
            // ... (Same gantry code as previous, no changes needed to visuals)
            const railMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.8, roughness: 0.2 });
            const carriageMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.7 });
            const aluminumMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.5, roughness: 0.5 });
            const beltMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            const motorBodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });

            gantryBridge = new THREE.Group();
            const endPlateGeo = new THREE.BoxGeometry(1, 10, 12);
            const leftPlate = new THREE.Mesh(endPlateGeo, aluminumMat); leftPlate.position.x = -48;
            const rightPlate = new THREE.Mesh(endPlateGeo, aluminumMat); rightPlate.position.x = 48;
            const wheelGeo = new THREE.CylinderGeometry(1.5, 1.5, 1, 16); wheelGeo.rotateZ(Math.PI / 2);
            const lw1 = new THREE.Mesh(wheelGeo, aluminumMat); lw1.position.set(-49, -4, 4);
            const lw2 = new THREE.Mesh(wheelGeo, aluminumMat); lw2.position.set(-49, -4, -4);
            const rw1 = new THREE.Mesh(wheelGeo, aluminumMat); rw1.position.set(49, -4, 4);
            const rw2 = new THREE.Mesh(wheelGeo, aluminumMat); rw2.position.set(49, -4, -4);
            gantryBridge.add(leftPlate, rightPlate, lw1, lw2, rw1, rw2);
            const railGeo = new THREE.CylinderGeometry(0.5, 0.5, 96, 12); railGeo.rotateZ(Math.PI / 2);
            const rail1 = new THREE.Mesh(railGeo, railMat); rail1.position.z = -3;
            const rail2 = new THREE.Mesh(railGeo, railMat); rail2.position.z = 3;
            const mountGeo = new THREE.BoxGeometry(2, 3, 2);
            const m1 = new THREE.Mesh(mountGeo, aluminumMat); m1.position.set(-47, 0, -3);
            const m2 = new THREE.Mesh(mountGeo, aluminumMat); m2.position.set(47, 0, -3);
            const m3 = new THREE.Mesh(mountGeo, aluminumMat); m3.position.set(-47, 0, 3);
            const m4 = new THREE.Mesh(mountGeo, aluminumMat); m4.position.set(47, 0, 3);
            gantryBridge.add(rail1, rail2, m1, m2, m3, m4);
            const nemaGeo = new THREE.BoxGeometry(4, 4, 4);
            const motorBody = new THREE.Mesh(nemaGeo, motorBodyMat); motorBody.position.set(-44, 2, -5); gantryBridge.add(motorBody);
            const beltLoopGeo = new THREE.BoxGeometry(88, 0.2, 0.5);
            const beltTop = new THREE.Mesh(beltLoopGeo, beltMat); beltTop.position.set(0, 2.5, -4);
            const beltBot = new THREE.Mesh(beltLoopGeo, beltMat); beltBot.position.set(0, 1.5, -4);
            gantryBridge.add(beltTop, beltBot);
            const pulleyGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 16);
            const p1 = new THREE.Mesh(pulleyGeo, aluminumMat); p1.position.set(-44, 2, -4);
            const p2 = new THREE.Mesh(pulleyGeo, aluminumMat); p2.position.set(44, 2, -4);
            gantryBridge.add(p1, p2);
            gantryBridge.position.y = 80; scene.add(gantryBridge);

            gantryCarriage = new THREE.Group();
            const carriageBody = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 9), carriageMat); gantryCarriage.add(carriageBody);
            const bearingGeo = new THREE.CylinderGeometry(1, 1, 3, 12); bearingGeo.rotateZ(Math.PI / 2);
            const b1 = new THREE.Mesh(bearingGeo, aluminumMat); b1.position.set(-2, -1, 3);
            const b2 = new THREE.Mesh(bearingGeo, aluminumMat); b2.position.set(2, -1, 3);
            const b3 = new THREE.Mesh(bearingGeo, aluminumMat); b3.position.set(-2, -1, -3);
            const b4 = new THREE.Mesh(bearingGeo, aluminumMat); b4.position.set(2, -1, -3);
            gantryCarriage.add(b1, b2, b3, b4);
            const clampGeo = new THREE.BoxGeometry(2, 1, 1);
            const clamp = new THREE.Mesh(clampGeo, aluminumMat); clamp.position.set(0, 1, -4); gantryCarriage.add(clamp);
            const spoolGeo = new THREE.CylinderGeometry(1.5, 1.5, 4, 16); spoolGeo.rotateX(Math.PI / 2);
            const spool = new THREE.Mesh(spoolGeo, new THREE.MeshStandardMaterial({ color: 0xffffff })); spool.position.set(0, 2, 0); gantryCarriage.add(spool);
            const grommet = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 8, 16), aluminumMat); grommet.rotation.x = Math.PI / 2; grommet.position.y = -1.1; gantryCarriage.add(grommet);
            const zMotorBody = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), motorBodyMat); zMotorBody.position.set(3, 2.5, 2); gantryCarriage.add(zMotorBody);
            gantryBridge.add(gantryCarriage);

            clawGroup = new THREE.Group();

            if (loadedClawModel) {
                const clawMesh = loadedClawModel.clone();
                // Adjust position/rotation to fit the rope connection point
                clawMesh.position.y = -5;
                clawMesh.rotation.y = Math.PI / 2; // Adjust if needed
                clawMesh.scale.set(7.5, 7.5, 7.5); // Reduced size

                // Enable Shadows
                clawMesh.traverse((c) => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });

                // Auto-detect fingers for animation
                fingers = [];
                clawMesh.traverse(c => {
                    if (c.name.includes('Finger') || c.name.includes('finger')) {
                        fingers.push(c);
                    }
                });

                // Fallback if no specific finger nodes found
                if (fingers.length === 0) {
                    clawMesh.children.forEach(c => fingers.push(c));
                }

                // Sort and assign axes
                fingers.sort((a, b) => a.name.localeCompare(b.name));
                fingers.forEach((child, i) => {
                    const angle = i * (Math.PI * 2 / 3);
                    child.userData.axis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
                    child.userData.currentAngle = 0;
                });

                clawGroup.add(clawMesh);
            } else {
                // Fallback (Keep simplified procedural if model fails)
                const housing = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 6, 16), new THREE.MeshStandardMaterial({ color: 0xf39c12 }));
                clawGroup.add(housing);
            }
            scene.add(clawGroup);

            const ropeContainer = new THREE.Group();
            const ropeGeo = new THREE.CylinderGeometry(0.15, 0.15, 1);
            ropeGeo.rotateX(-Math.PI / 2); ropeGeo.translate(0, 0, 0.5);
            const ropeBody = new THREE.Mesh(ropeGeo, new THREE.MeshBasicMaterial({ color: 0x111111 }));
            ropeContainer.add(ropeBody); ropeMesh = ropeContainer; scene.add(ropeMesh);

            class HelixCurve extends THREE.Curve {
                getPoint(t) {
                    const loops = 12; const angle = t * Math.PI * 2 * loops;
                    const radius = 0.8; const x = radius * Math.cos(angle); const z = radius * Math.sin(angle); const y = t * 20; // Positive Y
                    return new THREE.Vector3(x, y, z);
                }
            }
            const path = new HelixCurve(); const tubeGeo = new THREE.TubeGeometry(path, 128, 0.15, 6, false);
            const coilContainer = new THREE.Group(); tubeGeo.rotateX(Math.PI / 2); // Align Y to +Z for lookAt scaling
            const coilBody = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }));
            coilContainer.add(coilBody); coilMesh = coilContainer; scene.add(coilMesh);

            const chainPath = new THREE.CatmullRomCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
            const chainGeo = new THREE.TubeGeometry(chainPath, 16, 0.8, 4, false);
            dragChainMesh = new THREE.Mesh(chainGeo, new THREE.MeshStandardMaterial({ color: 0x222222 })); scene.add(dragChainMesh);
        }

        function spawnPrizes() {
            if (Object.keys(loadedPrizeModels).length === 0) {
                debugLog("No prize models loaded!");
                return;
            }

            let availableKeys = Object.keys(loadedPrizeModels);
            debugLog(`Spawning ${availableKeys.length} unique prizes...`);

            // Shuffle
            availableKeys.sort(() => Math.random() - 0.5);

            // Spawn one of each
            availableKeys.forEach(key => {
                const model = loadedPrizeModels[key].clone();

                // Random position
                model.position.x = (Math.random() - 0.5) * 60; // Reduced from 70 to avoid wall clipping
                model.position.z = (Math.random() - 0.5) * 60; // Reduced from 70
                // Lift them up higher so they don't spawn in the floor
                model.position.y = CONFIG.floorY + 5 + (Math.random() * 20);

                // Random rotation
                model.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                // Scale - Prizes might need scaling, let's assume 30x based on typical GLB units vs game units
                model.scale.set(30, 30, 30);

                // Shadows
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                scene.add(model);
                prizes.push(model);
            });
        }


        // --- Confetti System ---
        function createConfetti() {
            const particleCount = 100;
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];

            for (let i = 0; i < particleCount; i++) {
                // Eject from machine top center
                positions.push(0, 110, 0);
                // Random velocity outward
                velocities.push(
                    (Math.random() - 0.5) * 2,
                    (Math.random() * 1.5) + 0.5,
                    (Math.random() - 0.5) * 2
                );
                const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                colors.push(color.r, color.g, color.b);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({ size: 1.5, vertexColors: true });
            const particleSystem = new THREE.Points(geo, mat);
            particleSystem.userData = { velocities: velocities, age: 0 };

            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const positions = p.geometry.attributes.position.array;
                const vels = p.userData.velocities;

                p.userData.age++;

                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += vels[j];     // x
                    positions[j + 1] += vels[j + 1]; // y
                    positions[j + 2] += vels[j + 2]; // z

                    vels[j + 1] -= 0.02; // Gravity
                }
                p.geometry.attributes.position.needsUpdate = true;

                if (p.userData.age > 200) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // --- Logic ---
        function updateCreditDisplay() {
            const display = document.getElementById('creditDisplay');
            display.innerText = state.credits < 10 ? "0" + state.credits : state.credits;
            display.style.color = state.credits > 0 ? '#2ecc71' : '#e74c3c';
        }

        function insertCoin() { state.credits++; updateCreditDisplay(); }

        function tryDrop() {
            // Check for credits or free play
            if (state.credits > 0 && state.status === 'IDLE') {
                state.credits--;
                updateCreditDisplay();
                state.status = 'DROPPING';
                state.dropTargetY = CONFIG.floorY + 20; // Raised from +5 to prevent floor clipping
                if (soundManager) soundManager.playArcadeStart();
            } else if (state.credits <= 0) {
                // Auto replenish for free play feel if button removed
                state.credits = 1;
                updateCreditDisplay();
                state.status = 'DROPPING';
                state.dropTargetY = CONFIG.floorY + 20; // Raised from +5
                if (soundManager) soundManager.playArcadeStart();
            }
        }

        // --- Camera Animation State Machine ---
        let camTargetPos = new THREE.Vector3(0, 80, 280);
        let camLookAt = new THREE.Vector3(0, 20, 0);

        function updateCameraLogic() {
            if (state.cameraMode === 'TRANSITION_TO_PRIZE') {
                // Lerp to Prize view (Retreival Bin: x=-34, y=-60, z=50 approx)
                const targetP = new THREE.Vector3(0, -20, 150); // Zoomed in low
                const targetL = new THREE.Vector3(-34, CONFIG.floorY - 10, 40); // Look at retrieval box

                camera.position.lerp(targetP, 0.05);
                camLookAt.lerp(targetL, 0.05);
                camera.lookAt(camLookAt);

                if (camera.position.distanceTo(targetP) < 1) {
                    state.cameraMode = 'PRIZE_VIEW';
                    document.getElementById('collect-msg').style.display = 'block';
                    document.getElementById('ui-layer').style.opacity = '0';
                }
            } else if (state.cameraMode === 'TRANSITION_TO_GAME') {
                updateCameraPosition(); // Normal orbit logic calculates pos
                // But we need to tween LookAt back to center
                const targetL = new THREE.Vector3(0, 20, 0);
                camLookAt.lerp(targetL, 0.05);
                camera.lookAt(camLookAt);

                // Also manually lerp position if far
                const currentOrbitPos = new THREE.Vector3();
                const radius = 280;
                currentOrbitPos.x = radius * Math.sin(cameraAngle);
                currentOrbitPos.z = radius * Math.cos(cameraAngle);
                currentOrbitPos.y = cameraHeight;

                camera.position.lerp(currentOrbitPos, 0.05);

                if (camera.position.distanceTo(currentOrbitPos) < 2) {
                    state.cameraMode = 'GAME';
                    document.getElementById('ui-layer').style.opacity = '1';
                    state.status = 'RESETTING'; // Now reset machine
                }
            } else if (state.cameraMode === 'GAME') {
                // Handled by mouse orbit
            }
        }

        // Interactive Prize Rotation
        let isDraggingPrize = false;
        let prizeRotationVelocity = 0;
        let lastMouseX = 0;

        window.addEventListener('mousedown', (e) => {
            if (state.cameraMode === 'PRIZE_VIEW') {
                isDraggingPrize = true;
                lastMouseX = e.clientX;
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (state.cameraMode === 'PRIZE_VIEW' && isDraggingPrize && state.wonPrize) {
                const delta = e.clientX - lastMouseX;
                state.wonPrize.rotation.y += delta * 0.01;
                prizeRotationVelocity = delta * 0.01;
                lastMouseX = e.clientX;
            }
        });

        window.addEventListener('mouseup', () => {
            if (state.cameraMode === 'PRIZE_VIEW') {
                isDraggingPrize = false;
            }
        });

        // Click to collect (Only if not dragging)
        document.getElementById('collect-msg').addEventListener('click', () => {
            if (state.cameraMode === 'PRIZE_VIEW') {
                state.cameraMode = 'TRANSITION_TO_GAME';
                document.getElementById('collect-msg').style.display = 'none';
                if (state.wonPrize) {
                    scene.remove(state.wonPrize);
                    state.wonPrize = null;
                }
            }
        });

        function updatePhysics() {
            updateParticles();
            // ... (rest of function)

            // PRIZE VIEW INERTIA
            if (state.cameraMode === 'PRIZE_VIEW' && state.wonPrize && !isDraggingPrize) {
                state.wonPrize.rotation.y += prizeRotationVelocity;
                prizeRotationVelocity *= 0.95; // Damping
            }

            updateCameraLogic();

            // -- MOTOR SOUND LOGIC --
            const isMoving = (state.status === 'MOVING' || state.status === 'DROPPING' || state.status === 'LIFTING' || state.status === 'RETURNING' || state.status === 'RESETTING');
            const isManualMoving = (state.status === 'IDLE' && (playerInput.up || playerInput.down || playerInput.left || playerInput.right));

            if (soundManager) {
                soundManager.playMotor(isMoving || isManualMoving);
            }

            // -- MOVEMENT CONTROLLER --
            if (state.status === 'STARTUP') {
                const targetX = 0; const targetZ = 0;
                let dx = targetX - state.gantryX; let dz = targetZ - state.gantryZ;
                let dist = Math.sqrt(dx * dx + dz * dz);
                if (dist > 0.5) {
                    state.gantryX += (dx / dist) * 0.4; // Slower startup
                    state.gantryZ += (dz / dist) * 0.4;
                } else {
                    state.gantryX = 0; state.gantryZ = 0; state.status = 'IDLE';
                }
            }
            else if (state.status === 'RESETTING') {
                const targetX = 0; const targetZ = 0;
                let dx = targetX - state.gantryX; let dz = targetZ - state.gantryZ;
                let dist = Math.sqrt(dx * dx + dz * dz);
                if (dist > 0.5) {
                    state.gantryX += (dx / dist) * 0.8;
                    state.gantryZ += (dz / dist) * 0.8;
                } else {
                    state.gantryX = 0; state.gantryZ = 0; state.status = 'IDLE';
                }
            }
            else if (state.status === 'IDLE' && state.cameraMode === 'GAME') {
                // Check credits handled in tryDrop, movement allowed if credits > 0 or we treat as free play
                if (state.credits > 0) {
                    const speed = CONFIG.clawSpeed;
                    let dx = playerInput.analogX; let dz = playerInput.analogY;
                    if (playerInput.up) dz -= 1; if (playerInput.down) dz += 1;
                    if (playerInput.left) dx -= 1; if (playerInput.right) dx += 1;
                    dx = Math.max(-1, Math.min(1, dx)); dz = Math.max(-1, Math.min(1, dz));
                    state.gantryX += dx * speed; state.gantryZ += dz * speed;
                    state.gantryX = Math.max(-42, Math.min(42, state.gantryX));
                    state.gantryZ = Math.max(-40, Math.min(40, state.gantryZ));
                }
            }

            gantryBridge.position.z = state.gantryZ; gantryCarriage.position.x = state.gantryX;

            const targetX = state.gantryX; const targetZ = state.gantryZ;
            const forceX = (targetX - state.clawPos.x) * CONFIG.wiggleStiffness;
            const forceZ = (targetZ - state.clawPos.z) * CONFIG.wiggleStiffness;
            state.clawVel.x += forceX; state.clawVel.z += forceZ;
            state.clawVel.x *= CONFIG.wiggleDamping; state.clawVel.z *= CONFIG.wiggleDamping;
            state.clawPos.x += state.clawVel.x; state.clawPos.z += state.clawVel.z;

            if (state.status === 'DROPPING') {
                state.clawY -= CONFIG.dropSpeed;

                // 1. Floor Collision
                // Stop slightly above floor to avoid clipping
                const floorLimit = CONFIG.floorY + 8;
                if (state.clawY <= floorLimit) {
                    state.clawY = floorLimit;
                    state.status = 'GRABBING';
                    setTimeout(closeClaw, 1000);
                    return;
                }

                // 2. Prize Collision
                // Check if we hit any prize
                // Approximate claw touch width and height
                const hitRadius = 8;
                const clawBottom = state.clawY;

                for (let p of prizes) {
                    // Simple box/sphere check
                    const dx = state.clawPos.x - p.position.x;
                    const dz = state.clawPos.z - p.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < hitRadius) {
                        // Horizontal hit, check vertical
                        // Prize top approximation (y + scale/size)
                        // Prizes are scaled 30x, typical GLB center is 0.
                        // Let's assume top is y + 5 (roughly)
                        const prizeTop = p.position.y + 5;

                        if (clawBottom <= prizeTop && clawBottom > p.position.y - 5) {
                            // Hit!
                            state.clawY = prizeTop;
                            state.status = 'GRABBING';
                            setTimeout(closeClaw, 1000);
                            return;
                        }
                    }
                }

                if (state.clawY <= state.dropTargetY) { state.status = 'GRABBING'; setTimeout(closeClaw, 1000); }
            } else if (state.status === 'LIFTING') {
                state.clawY += CONFIG.clawSpeed;
                if (state.clawY >= CONFIG.clawRestY) { state.status = 'RETURNING'; }
            } else if (state.status === 'RETURNING') {
                const homeX = -34; const homeZ = 34; const speed = 0.5;
                let dx = homeX - state.gantryX; let dz = homeZ - state.gantryZ;
                if (Math.abs(dx) > 1) state.gantryX += Math.sign(dx) * speed;
                if (Math.abs(dz) > 1) state.gantryZ += Math.sign(dz) * speed;
                if (Math.abs(dx) < 1.5 && Math.abs(dz) < 1.5) { state.status = 'RELEASING'; setTimeout(openClaw, 1000); }
            }

            clawGroup.position.set(state.clawPos.x, state.clawY, state.clawPos.z);
            clawGroup.rotation.z = -(state.gantryX - state.clawPos.x) * 0.08;
            clawGroup.rotation.x = (state.gantryZ - state.clawPos.z) * 0.08;

            const topY = 80;
            const hookOffset = 9; // Adjusted for smaller claw (was 18)
            const clawTopY = state.clawY + hookOffset;

            const anchorVec = new THREE.Vector3(state.gantryX, topY, state.gantryZ);
            const clawVec = new THREE.Vector3(state.clawPos.x, clawTopY, state.clawPos.z);
            ropeMesh.position.copy(anchorVec); ropeMesh.lookAt(clawVec); ropeMesh.scale.z = anchorVec.distanceTo(clawVec);

            const coilAnchor = anchorVec.clone().add(new THREE.Vector3(1, 0, 1)); // Reduced from 3
            const coilClaw = clawVec.clone().add(new THREE.Vector3(1, 2, 1)); // Reduced from 3,5,3 to be closer to hook
            coilMesh.position.copy(coilAnchor); coilMesh.lookAt(coilClaw);
            coilMesh.scale.set(1, 1, Math.max(0.1, coilAnchor.distanceTo(coilClaw) / 20));

            if (state.heldPrize) {
                state.heldPrize.position.set(state.clawPos.x, state.clawY - 25, state.clawPos.z);

                // Squishy Physics
                const t = Date.now() * 0.005;
                const squish = Math.sin(t) * 0.1; // +/- 10%
                // Y compressed (25-30), X/Z bulged (30-35)
                state.heldPrize.scale.set(30 * (1 + squish), 30 * (1 - squish), 30 * (1 + squish));

                state.heldPrize.rotation.z = clawGroup.rotation.z;
                state.heldPrize.rotation.x = clawGroup.rotation.x + (Date.now() * 0.001);
            } else if (state.wonPrize && state.status === 'WIN_SEQUENCE') {
                state.wonPrize.scale.set(30, 30, 30); // Restore scale
                // Animate drop into bin
                if (state.wonPrize.position.y > CONFIG.floorY - 15) {
                    state.wonPrize.position.y -= 1.0; // Fall
                }
            }

            const start = new THREE.Vector3(-48, 82, state.gantryZ);
            const end = new THREE.Vector3(state.gantryX, 82, state.gantryZ);
            const mid = start.clone().lerp(end, 0.5); mid.y += 10;
            dragChainMesh.geometry.dispose();
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            dragChainMesh.geometry = new THREE.TubeGeometry(curve, 10, 0.8, 4, false);
        }

        function closeClaw() {
            state.clawOpen = false;
            let closest = null; let minDist = 12;
            prizes.forEach(p => {
                const dx = p.position.x - state.clawPos.x; const dz = p.position.z - state.clawPos.z;
                if (Math.sqrt(dx * dx + dz * dz) < minDist) closest = p;
            });
            if (closest) {
                if (Math.random() < CONFIG.winRatio) {
                    state.heldPrize = closest;
                } else {
                    closest.position.x += (Math.random() - 0.5) * 5;
                    closest.position.z += (Math.random() - 0.5) * 5;
                    triggerEvent('LOSS');
                }
            } else {
                triggerEvent('LOSS');
            }
            setTimeout(() => { state.status = 'LIFTING'; }, 1000);
        }

        function openClaw() {
            state.clawOpen = true;
            if (state.heldPrize) {
                triggerEvent('WIN');
                state.wonPrize = state.heldPrize;
                state.heldPrize = null;
                state.status = 'WIN_SEQUENCE';

                // 2 Second Delay before camera move
                setTimeout(() => {
                    state.cameraMode = 'TRANSITION_TO_PRIZE';
                    createConfetti(); // EXPLOSION
                }, 2000);
            } else {
                setTimeout(() => { state.status = 'RESETTING'; }, 1000);
            }
        }

        function updateLEDs() {
            const time = Date.now() * 0.0002; // Slower LEDs
            ledStrips.forEach((strip, i) => {
                let hue;
                if (state.status === 'STARTUP') { hue = (time * 5 + (i * 0.5)) % 1; }
                else { hue = (time + (i * 0.2)) % 1; }
                strip.material.emissive.setHSL(hue, 1, 0.5);
                if (ledPointLights[i]) ledPointLights[i].color.setHSL(hue, 1, 0.5);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateLEDs();
            updateMarquee();
            // Animate Fingers
            // 0 = Open, 0.4 = Closed (Adjust based on model)
            const targetFingerAngle = state.clawOpen ? 0 : 0.4;

            fingers.forEach(f => {
                if (f.userData.currentAngle === undefined) f.userData.currentAngle = 0;

                // Smoothly interpolate angle
                f.userData.currentAngle += (targetFingerAngle - f.userData.currentAngle) * 0.1;

                // Apply rotation
                if (f.userData.axis) {
                    f.quaternion.setFromAxisAngle(f.userData.axis, f.userData.currentAngle);
                } else {
                    // Fallback
                    f.rotation.z = f.userData.currentAngle;
                }
            });
            renderer.render(scene, camera);
        }

        function setupInputListeners() {
            // Only Drop Button needed
            document.getElementById('dropBtn').addEventListener('click', tryDrop);
            document.getElementById('dropBtn').addEventListener('touchstart', (e) => { e.preventDefault(); tryDrop(); });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') playerInput.up = true; if (e.key === 'ArrowDown') playerInput.down = true;
                if (e.key === 'ArrowLeft') playerInput.left = true; if (e.key === 'ArrowRight') playerInput.right = true;
                if (e.code === 'Space') tryDrop();
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowUp') playerInput.up = false; if (e.key === 'ArrowDown') playerInput.down = false;
                if (e.key === 'ArrowLeft') playerInput.left = false; if (e.key === 'ArrowRight') playerInput.right = false;
            });
        }

        function setupJoystick() {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            const stick = document.getElementById('joystick-stick');
            let isDraggingJoystick = false; let startX, startY; const maxRadius = 40;

            const handleStart = (clientX, clientY) => {
                isDraggingJoystick = true; const rect = zone.getBoundingClientRect();
                startX = rect.left + rect.width / 2; startY = rect.top + rect.height / 2;
            };
            const handleMove = (clientX, clientY) => {
                if (!isDraggingJoystick) return;
                let dx = clientX - startX; let dy = clientY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                let visualDx = dx;
                let visualDy = dy;

                if (distance > maxRadius) {
                    const ratio = maxRadius / distance;
                    dx *= ratio; dy *= ratio;
                    visualDx = dx; visualDy = dy;
                }

                // Update Knob
                knob.style.transform = `translate(calc(-50% + ${visualDx}px), calc(-50% + ${visualDy}px))`;

                // Update Stick
                // Angle calculation in Radians
                const angle = Math.atan2(visualDy, visualDx);
                const dist = Math.sqrt(visualDx * visualDx + visualDy * visualDy);

                stick.style.width = dist + 'px';
                stick.style.transform = `translate(0, -50%) rotate(${angle}rad)`;

                // Update Input State
                playerInput.analogX = dx / maxRadius; playerInput.analogY = dy / maxRadius;
            };
            const handleEnd = () => {
                isDraggingJoystick = false;
                knob.style.transform = `translate(-50%, -50%)`;
                stick.style.width = '0px';
                playerInput.analogX = 0; playerInput.analogY = 0;
            };

            zone.addEventListener('mousedown', e => { e.stopPropagation(); handleStart(e.clientX, e.clientY); });
            window.addEventListener('mousemove', e => { handleMove(e.clientX, e.clientY); });
            window.addEventListener('mouseup', handleEnd);
            zone.addEventListener('touchstart', e => { e.stopPropagation(); e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); });
            zone.addEventListener('touchmove', e => { e.stopPropagation(); e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); });
            zone.addEventListener('touchend', handleEnd);
        }

        let isDragging = false; let previousMousePosition = { x: 0, y: 0 }; let cameraAngle = 0; let cameraHeight = 80;
        function setupMouseOrbit() {
            document.addEventListener('mousedown', (e) => { if (e.target.closest('.control-panel')) return; isDragging = true; });
            document.addEventListener('mouseup', () => isDragging = false);
            document.addEventListener('mousemove', (e) => {
                if (isDragging && state.cameraMode === 'GAME') {
                    const deltaMove = { x: e.offsetX - previousMousePosition.x, y: e.offsetY - previousMousePosition.y };
                    cameraAngle -= deltaMove.x * 0.01; cameraHeight += deltaMove.y * 0.2;
                    cameraHeight = Math.max(10, Math.min(250, cameraHeight)); updateCameraPosition();
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
        }
        function updateCameraPosition() {
            const radius = 280; camera.position.x = radius * Math.sin(cameraAngle);
            camera.position.z = radius * Math.cos(cameraAngle); camera.position.y = cameraHeight;
            camera.lookAt(0, 20, 0);
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        try {
            loadAssets(() => {
                try {
                    init();
                } catch (e) {
                    const el = document.getElementById('debug-overlay');
                    if (el) el.innerHTML += '<br>CRITICAL INIT ERROR: ' + e.message;
                    console.error(e);
                }
            });
        } catch (e) {
            const el = document.getElementById('debug-overlay');
            if (el) el.innerHTML += '<br>CRITICAL STARTUP ERROR: ' + e.message;
            console.error(e);
        }
    </script>
</body>

</html>