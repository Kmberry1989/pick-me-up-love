<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Claw Crane Game - Coin & Ticket System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            color: #0ff;
            font-family: monospace;
            touch-action: none;
        }

        #score,
        #credits,
        #tickets {
            position: absolute;
            top: 10px;
            background: rgba(0, 0, 0, 0.88);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 16px;
            pointer-events: none;
            z-index: 25;
        }

        #score {
            left: 10px;
        }

        #credits {
            left: 330px;
        }

        #tickets {
            left: 470px;
        }

        #drop {
            position: absolute;
            bottom: 30px;
            left: calc(50% + 100px);
            /* To the right of the centered joystick */
            right: auto;
            width: 100px;
            height: 100px;

            border-radius: 50%;
            background: #28a745;
            color: white;
            font-size: 20px;
            font-weight: bold;
            border: 4px solid #1e7e34;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        #drop[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.3);
        }

        #drop:active {
            background: #1e7e34;
            transform: scale(0.95);
        }

        button {
            border: none;
            cursor: pointer;
            user-select: none;
        }

        #insertCoin {
            position: absolute;
            top: 10px;
            right: 220px;
            background: #00aa00;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 4px;
            color: white;
        }

        #toggleCatalog {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #0088ff;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 4px;
            color: white;
        }

        #zone_joystick {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            z-index: 10;
        }

        #catalog {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 6px;
            display: none;
            z-index: 20;
        }


        #catalog h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
        }

        .catalog-item {
            margin: 4px 0;
            cursor: pointer;
            padding: 5px;
            border-bottom: 1px solid #333;
        }

        .catalog-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .catalog-item span {
            float: right;
        }

        canvas {
            display: block;
        }

        @media (max-width: 700px) {
            #score,
            #credits,
            #tickets {
                left: 10px;
                top: 8px;
                font-size: 14px;
                padding: 6px 8px;
            }

            #credits {
                top: 36px;
            }

            #tickets {
                top: 64px;
            }

            #insertCoin {
                top: 8px;
                right: 10px;
                padding: 10px 12px;
                font-size: 13px;
            }

            #toggleCatalog {
                top: 46px;
                right: 10px;
                padding: 10px 12px;
                font-size: 13px;
            }

            #zone_joystick {
                width: 120px;
                height: 120px;
                bottom: 12%;
            }

            #drop {
                width: 90px;
                height: 90px;
                left: calc(50% + 85px);
                bottom: 12%;
                font-size: 18px;
            }
        }
    </style>
</head>

<body>
    <div id="score">Prizes: 0 Free: 0 Turns: 5</div>
    <div id="credits">Credits: 0</div>
    <div id="tickets">Tickets: 0</div>

    <button id="insertCoin">üí∞ Insert Coin</button>
    <button id="toggleCatalog">üéÅ Catalog</button>

    <div id="zone_joystick"></div>

    <button id="drop">DROP</button>


    <div id="catalog">
        <h3>Prize Catalog</h3>
    </div>
    <canvas></canvas>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'https://cdn.skypack.dev/cannon-es';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Audio Manager (Web Audio API)
        class AudioManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.motorOsc = null;
                this.motorGain = null;
                this.isPlayingMotor = false;
            }

            // Procedural Motor Sound (Whirring)
            startMotor(pitch = 200) {
                if (this.isPlayingMotor) return;
                this.isPlayingMotor = true;

                this.motorOsc = this.ctx.createOscillator();
                this.motorOsc.type = 'sawtooth';
                this.motorOsc.frequency.setValueAtTime(pitch, this.ctx.currentTime);

                this.motorGain = this.ctx.createGain();
                this.motorGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.motorGain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.1);

                // Filter to muffle it a bit like a motor
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;

                this.motorOsc.connect(filter);
                filter.connect(this.motorGain);
                this.motorGain.connect(this.masterGain);
                this.motorOsc.start();
            }

            stopMotor() {
                if (!this.isPlayingMotor) return;
                // "DJ Scratch" / Power down effect
                const now = this.ctx.currentTime;
                // Pitch drop
                this.motorOsc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                // Volume cut
                this.motorGain.gain.linearRampToValueAtTime(0, now + 0.3);

                this.motorOsc.stop(now + 0.3);
                this.isPlayingMotor = false;
            }

            playTone(freq, type, duration) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playWin() {
                // Arpeggio
                [440, 554, 659, 880].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.4), i * 150));
            }

            playLose() {
                [300, 250, 200].forEach((f, i) => setTimeout(() => this.playTone(f, 'triangle', 0.5), i * 300));
            }
        }
        const audio = new AudioManager();
        // User interaction required to start AudioContext usually, will handle on first input


        // UI Elements
        const scoreEl = document.getElementById('score');
        const creditsEl = document.getElementById('credits');
        const ticketsEl = document.getElementById('tickets');
        const catalogEl = document.getElementById('catalog');
        const catalogBtn = document.getElementById('toggleCatalog');

        // Game State
        const testMode = new URLSearchParams(window.location.search).get('test') === '1';
        let prizeCount = 0, freeTurns = 0, turns = 5, credits = 0, tickets = 0;
        const catalog = [
            { name: 'Stuffed Bear', cost: 50 },
            { name: 'Toy Car', cost: 30 },
            { name: 'Keychain', cost: 15 }
        ];

        function updateUI() {
            scoreEl.innerText = `Prizes: ${prizeCount}  Free: ${freeTurns}  Turns: ${turns}`;
            creditsEl.innerText = `Credits: ${credits}`;
            ticketsEl.innerText = `Tickets: ${tickets}`;
        }

        // Populate catalog
        catalog.forEach(item => {
            const div = document.createElement('div');
            div.className = 'catalog-item';
            div.innerHTML = `${item.name} <span>${item.cost}</span>`;
            div.onclick = () => {
                if (tickets >= item.cost) {
                    tickets -= item.cost;
                    alert(`Redeemed ${item.name}!`);
                    updateUI();
                } else alert('Not enough tickets');
            };
            catalogEl.appendChild(div);
        });

        catalogBtn.onclick = () => {
            const isHidden = window.getComputedStyle(catalogEl).display === 'none';
            catalogEl.style.display = isHidden ? 'block' : 'none';
        };

        // Coin insertion
        document.getElementById('insertCoin').onclick = () => { credits++; turns++; updateUI(); };

        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 100, 200);
        const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = false;

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.minDistance = 90;
        controls.maxDistance = 420;


        // Lights
        // Lights
        scene.background = new THREE.Color(0x0b0b18);
        scene.fog = new THREE.FogExp2(0x0b0b18, 0.007);

        scene.add(new THREE.AmbientLight(0x777777, 1.6));
        scene.add(new THREE.HemisphereLight(0xffffee, 0x2a2a45, 0.9));

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = false;
        scene.add(dirLight);

        const floorCanvas = document.createElement('canvas');
        floorCanvas.width = 256;
        floorCanvas.height = 256;
        const floorCtx = floorCanvas.getContext('2d');
        if (floorCtx) {
            const grad = floorCtx.createLinearGradient(0, 0, 0, 256);
            grad.addColorStop(0, '#0f0f24');
            grad.addColorStop(1, '#05050d');
            floorCtx.fillStyle = grad;
            floorCtx.fillRect(0, 0, 256, 256);
            floorCtx.strokeStyle = 'rgba(0, 255, 255, 0.14)';
            floorCtx.lineWidth = 1;
            for (let i = 0; i <= 256; i += 32) {
                floorCtx.beginPath();
                floorCtx.moveTo(i, 0);
                floorCtx.lineTo(i, 256);
                floorCtx.stroke();
                floorCtx.beginPath();
                floorCtx.moveTo(0, i);
                floorCtx.lineTo(256, i);
                floorCtx.stroke();
            }
        }
        const floorTex = new THREE.CanvasTexture(floorCanvas);
        floorTex.wrapS = THREE.RepeatWrapping;
        floorTex.wrapT = THREE.RepeatWrapping;
        floorTex.repeat.set(6, 6);
        if (renderer.capabilities.getMaxAnisotropy) {
            floorTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        }
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(240, 240),
            new THREE.MeshStandardMaterial({ map: floorTex, metalness: 0.1, roughness: 0.9 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -1.2;
        scene.add(floor);

        const roomMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a3a,
            emissive: 0x111126,
            emissiveIntensity: 0.35,
            transparent: true,
            opacity: 0.36,
            roughness: 0.85,
            metalness: 0.05,
            side: THREE.DoubleSide
        });
        const roomSize = 260;
        const roomHeight = 160;
        const roomWallGeo = new THREE.PlaneGeometry(roomSize, roomHeight);
        const roomHalf = roomSize / 2;
        const roomWallY = roomHeight / 2;
        const roomBack = new THREE.Mesh(roomWallGeo, roomMat);
        roomBack.position.set(0, roomWallY, -roomHalf);
        scene.add(roomBack);
        const roomFront = new THREE.Mesh(roomWallGeo, roomMat);
        roomFront.position.set(0, roomWallY, roomHalf);
        roomFront.rotation.y = Math.PI;
        scene.add(roomFront);
        const roomLeft = new THREE.Mesh(roomWallGeo, roomMat);
        roomLeft.position.set(-roomHalf, roomWallY, 0);
        roomLeft.rotation.y = Math.PI / 2;
        scene.add(roomLeft);
        const roomRight = new THREE.Mesh(roomWallGeo, roomMat);
        roomRight.position.set(roomHalf, roomWallY, 0);
        roomRight.rotation.y = -Math.PI / 2;
        scene.add(roomRight);
        const roomCeil = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), roomMat);
        roomCeil.position.set(0, roomHeight, 0);
        roomCeil.rotation.x = Math.PI / 2;
        scene.add(roomCeil);

        const dustCount = 160;
        const dustPositions = new Float32Array(dustCount * 3);
        for (let i = 0; i < dustCount; i++) {
            dustPositions[i * 3] = (Math.random() - 0.5) * 160;
            dustPositions[i * 3 + 1] = 10 + Math.random() * 70;
            dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 160;
        }
        const dustGeo = new THREE.BufferGeometry();
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
        const dustMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0.45, depthWrite: false });
        const dust = new THREE.Points(dustGeo, dustMat);
        scene.add(dust);

        // Arcade Cabinet Internal SpotLight
        const spotLight = new THREE.SpotLight(0xffdd88, 4.2);
        spotLight.position.set(0, 85, 15);
        spotLight.angle = Math.PI / 3.1;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 280;
        spotLight.target.position.set(0, 0, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        const cabinetFill = new THREE.PointLight(0xffffff, 1.4, 170);
        cabinetFill.position.set(0, 42, 12);
        scene.add(cabinetFill);

        const cabinetFillLow = new THREE.PointLight(0x88bbff, 1.05, 150);
        cabinetFillLow.position.set(0, 18, -8);
        scene.add(cabinetFillLow);

        const neonCyan = new THREE.PointLight(0x00ffff, 1.1, 320);
        neonCyan.position.set(90, 70, 80);
        scene.add(neonCyan);

        const neonMagenta = new THREE.PointLight(0xff33cc, 1.05, 300);
        neonMagenta.position.set(-90, 60, -60);
        scene.add(neonMagenta);

        const overhead = new THREE.PointLight(0xffffff, 1.2, 420);
        overhead.position.set(0, 140, 0);
        scene.add(overhead);

        const rimWarm = new THREE.PointLight(0xffaa88, 0.9, 260);
        rimWarm.position.set(-120, 45, 120);
        scene.add(rimWarm);

        const rimCool = new THREE.PointLight(0x88ccff, 0.9, 260);
        rimCool.position.set(120, 55, -120);
        scene.add(rimCool);

        // Light Manager
        class LightManager {
            constructor() {
                this.mode = 'IDLE'; // IDLE, WIN, LOSE, PLAY
                this.timer = 0;
                this.leds = [];
            }

            addLed(mesh) { this.leds.push(mesh); }

            update(dt) {
                this.timer += dt;
                const t = this.timer;

                this.leds.forEach((led, i) => {
                    const mat = led.material;
                    if (this.mode === 'IDLE') {
                        // Rainbow Wave
                        const hue = (t * 0.2 + i * 0.1) % 1;
                        mat.color.setHSL(hue, 1, 0.5);
                        mat.emissive.setHSL(hue, 1, 0.5);
                    } else if (this.mode === 'PLAY') {
                        mat.color.setHex(0xffaa00);
                        mat.emissive.setHex(0xffaa00);
                        mat.emissiveIntensity = 1 + Math.sin(t * 10) * 0.5;
                    } else if (this.mode === 'WIN') {
                        // Green Strobe
                        const on = Math.floor(t * 20) % 2 === 0;
                        mat.color.setHex(on ? 0x00ff00 : 0x000000);
                        mat.emissive.setHex(on ? 0x00ff00 : 0x000000);
                        mat.emissiveIntensity = 2;
                    } else if (this.mode === 'LOSE') {
                        // Slow Blue Pulse
                        const val = 0.5 + Math.sin(t * 2) * 0.5;
                        mat.color.setHex(0x0000ff);
                        mat.emissive.setHex(0x0000ff);
                        mat.emissiveIntensity = val;
                    }
                });
            }

            setMode(m) { this.mode = m; this.timer = 0; }
        }
        const lights = new LightManager();


        const MACHINE_SCALE = 14;
        const WORLD_SCALE = MACHINE_SCALE;

        // Physics
        const world = new CANNON.World();
        world.gravity.set(0, -9.82 * WORLD_SCALE, 0);
        world.allowSleep = true;
        world.broadphase = new CANNON.NaiveBroadphase();
        world.defaultContactMaterial.friction = 0.5;
        world.defaultContactMaterial.restitution = 0.2;
        const physicsBodies = new Map();
        const physicsMeshes = [];
        const floorMaterial = new CANNON.Material('floor');
        const objectMaterial = new CANNON.Material('object');
        world.addContactMaterial(new CANNON.ContactMaterial(floorMaterial, objectMaterial, {
            friction: 0.6,
            restitution: 0.15
        }));

        // Machine Base (with Hole)
        // Floor pieces to create a hole at bottom-left (-x, +z)
        const machine = new THREE.Group();
        scene.add(machine);
        machine.scale.set(MACHINE_SCALE, MACHINE_SCALE, MACHINE_SCALE);
        const ROOF_Y = 6;
        const CLAW_TOP_Y = 5.5;
        const FLOOR_Y = 2.4;
        const FLOOR_THICKNESS = 0.5;
        const FLOOR_TOP_Y = FLOOR_Y + FLOOR_THICKNESS / 2;
        const CLAW_BOTTOM_Y = FLOOR_TOP_Y - 0.05;
        const SPAWN_BOUNDS = { minX: -3.2, maxX: 3.2, minZ: -3.2, maxZ: 3.2 };

        const baseMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.3, roughness: 0.7 });

        // Floor Parts (Hole at corner approx -2 to -4 X, 2 to 4 Z)
        // Main floor right
        const f1 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 8), baseMat);
        f1.position.set(2, FLOOR_Y, 0);
        machine.add(f1);

        // Floor part top-left
        const f2 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), baseMat);
        f2.position.set(-2, FLOOR_Y, -2);
        machine.add(f2);

        // Chute "Hole" visual (black box below)
        const hole = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.2, 3.8), new THREE.MeshBasicMaterial({ color: 0x000000 }));
        hole.position.set(-2, FLOOR_Y - 0.35, 2);
        machine.add(hole);

        function toWorld(v) {
            return new CANNON.Vec3(v.x * WORLD_SCALE, v.y * WORLD_SCALE, v.z * WORLD_SCALE);
        }

        function addStaticBox(halfExtents, position, material) {
            const body = new CANNON.Body({ mass: 0, material });
            const scaledHalf = new CANNON.Vec3(halfExtents.x * WORLD_SCALE, halfExtents.y * WORLD_SCALE, halfExtents.z * WORLD_SCALE);
            body.addShape(new CANNON.Box(scaledHalf));
            const worldPos = toWorld(position);
            body.position.set(worldPos.x, worldPos.y, worldPos.z);
            world.addBody(body);
            return body;
        }

        function addDynamicBody(mesh, shape, mass = 1) {
            const body = new CANNON.Body({ mass, material: objectMaterial });
            body.addShape(shape);
            const worldPos = toWorld(mesh.position);
            body.position.set(worldPos.x, worldPos.y, worldPos.z);
            body.linearDamping = 0.2;
            body.angularDamping = 0.3;
            world.addBody(body);
            physicsBodies.set(mesh, body);
            physicsMeshes.push(mesh);
            return body;
        }

        function removePhysicsForMesh(mesh) {
            const body = physicsBodies.get(mesh);
            if (body) {
                world.removeBody(body);
                physicsBodies.delete(mesh);
                const idx = physicsMeshes.indexOf(mesh);
                if (idx !== -1) physicsMeshes.splice(idx, 1);
            }
        }

        // Physics floor pieces (match f1/f2 geometry)
        addStaticBox(new CANNON.Vec3(2, FLOOR_THICKNESS / 2, 4), new CANNON.Vec3(2, FLOOR_Y, 0), floorMaterial);
        addStaticBox(new CANNON.Vec3(2, FLOOR_THICKNESS / 2, 2), new CANNON.Vec3(-2, FLOOR_Y, -2), floorMaterial);

        // Physics walls (glass boundaries)
        addStaticBox(new CANNON.Vec3(4, 3, 0.1), new CANNON.Vec3(0, 3, 4), floorMaterial);
        addStaticBox(new CANNON.Vec3(4, 3, 0.1), new CANNON.Vec3(0, 3, -4), floorMaterial);
        addStaticBox(new CANNON.Vec3(0.1, 3, 4), new CANNON.Vec3(4, 3, 0), floorMaterial);
        addStaticBox(new CANNON.Vec3(0.1, 3, 4), new CANNON.Vec3(-4, 3, 0), floorMaterial);

        const glassMat = new THREE.MeshStandardMaterial({ color: 0xddeeff, transparent: true, opacity: 0.18, side: THREE.DoubleSide });
        [[-4, 0], [4, 0], [0, -4], [0, 4]].forEach(([x, z]) => {
            const geo = new THREE.BoxGeometry(x === 0 ? 8 : 0.2, 6, z === 0 ? 8 : 0.2); // Reduced height 8->6
            const mesh = new THREE.Mesh(geo, glassMat);
            mesh.position.set(x, 3, z); // Center at 3
            machine.add(mesh);
        });
        const top = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), baseMat);
        top.position.y = ROOF_Y;
        machine.add(top);

        const neonStripMat = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 1.5,
            metalness: 0.2,
            roughness: 0.4
        });
        const stripLong = new THREE.BoxGeometry(8.2, 0.1, 0.1);
        const stripShort = new THREE.BoxGeometry(0.1, 0.1, 8.2);
        [
            [0, 0.55, 4.05, stripLong],
            [0, 0.55, -4.05, stripLong],
            [4.05, 0.55, 0, stripShort],
            [-4.05, 0.55, 0, stripShort]
        ].forEach(([x, y, z, geo]) => {
            const strip = new THREE.Mesh(geo, neonStripMat);
            strip.position.set(x, y, z);
            machine.add(strip);
        });

        // LEDs
        // LEDs
        const ledMat = new THREE.MeshStandardMaterial({ emissive: 0x00ffaa, emissiveIntensity: 1.5, color: 0x003300 });
        const ledGeo = new THREE.CylinderGeometry(0.1, 0.1, 6, 8); // Height reduced 8->6
        const leds = [[-4, 3, -4], [4, 3, -4], [-4, 3, 4], [4, 3, 4]].map(pos => { // Y pos 4->3
            const m = new THREE.Mesh(ledGeo, ledMat.clone()); // Clone for individual control
            m.position.set(...pos);
            // Vertical by default (Cylinder is Y-axis aligned)
            machine.add(m);
            lights.addLed(m);
            return m;
        });



        // Chute (aligned with hole at -2, 2 in machine coordinates)
        const chuteBaseMat = new THREE.MeshStandardMaterial({ color: 0xffcc33, metalness: 0.2, roughness: 0.6 });
        const chuteGlowMat = new THREE.MeshStandardMaterial({
            color: 0xffee88,
            emissive: 0xffcc55,
            emissiveIntensity: 1.2,
            metalness: 0.1,
            roughness: 0.3
        });
        const chuteBase = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.14, 1.0), chuteBaseMat);
        chuteBase.position.set(-2, FLOOR_TOP_Y + 0.06, 2);
        machine.add(chuteBase);
        const chuteRim = new THREE.Mesh(new THREE.BoxGeometry(1.16, 0.05, 1.16), chuteGlowMat);
        chuteRim.position.set(-2, FLOOR_TOP_Y + 0.12, 2);
        machine.add(chuteRim);

        // Claw
        const clawGroup = new THREE.Group();
        // Pivot group for physics wiggle
        const clawPivot = new THREE.Group();
        clawGroup.add(clawPivot);
        clawGroup.position.set(0, CLAW_TOP_Y, 0); // Lower start pos
        machine.add(clawGroup);

        const dropButton = document.getElementById('drop');
        let clawReady = false;
        dropButton.disabled = true;

        // Claw Cord (visual only)
        const cordGeo = new THREE.CylinderGeometry(0.05, 0.05, 1);
        const cordMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const cord = new THREE.Mesh(cordGeo, cordMat);
        cord.position.y = 1.2;
        clawGroup.add(cord);

        // Custom Claw Model
        const fingers = [];
        const clawLoader = new GLTFLoader();
        clawLoader.load('./models/custom_claw.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(0.25, 0.25, 0.25); // Reduced 10x
            model.position.y = -0.2;
            clawPivot.add(model);

            // Find fingers and assign explicit axes by name/index
            model.traverse((child) => {
                if (child.name.startsWith('Finger')) {
                    fingers.push(child);
                }
            });
            // Sort to ensure 1, 2, 3 order
            fingers.sort((a, b) => a.name.localeCompare(b.name));

            fingers.forEach((child, i) => {
                // Assume 3 fingers at 0, 120, 240 degrees
                // If origins are 0,0,0, we force this distribution
                const angle = i * (Math.PI * 2 / 3);
                // Tangent vector for rotation axis (Perpendicular to radius)
                // Radius assumed closely aligned with angle. Tangent is (-sin, 0, cos)
                child.userData.axis = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).normalize();
                child.userData.currentAngle = 0;
            });
            clawReady = true;
            dropButton.disabled = false;
        }, undefined, (err) => console.error('Error loading claw:', err));



        // Balls & Prizes
        const balls = [];
        const prizeSpawnSpheres = [];

        function isHole(x, z) {
            return Math.hypot(x + 2, z - 2) < 1.4;
        }

        function getPrizeSpawnPosition(radius) {
            for (let attempt = 0; attempt < 50; attempt++) {
                const minX = SPAWN_BOUNDS.minX + radius;
                const maxX = SPAWN_BOUNDS.maxX - radius;
                const minZ = SPAWN_BOUNDS.minZ + radius;
                const maxZ = SPAWN_BOUNDS.maxZ - radius;
                if (minX >= maxX || minZ >= maxZ) break;
                const x = minX + Math.random() * (maxX - minX);
                const z = minZ + Math.random() * (maxZ - minZ);
                if (isHole(x, z)) continue;
                let ok = true;
                for (const s of prizeSpawnSpheres) {
                    if (Math.hypot(x - s.x, z - s.z) < radius + s.r + 0.2) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    prizeSpawnSpheres.push({ x, z, r: radius });
                    return { x, z };
                }
            }
            const fallback = {
                x: (SPAWN_BOUNDS.minX + SPAWN_BOUNDS.maxX) * 0.5,
                z: (SPAWN_BOUNDS.minZ + SPAWN_BOUNDS.maxZ) * 0.5
            };
            return fallback;
        }

        function getBallSpawnPosition() {
            for (let attempt = 0; attempt < 30; attempt++) {
                const radius = 0.2;
                const minX = SPAWN_BOUNDS.minX + radius;
                const maxX = SPAWN_BOUNDS.maxX - radius;
                const minZ = SPAWN_BOUNDS.minZ + radius;
                const maxZ = SPAWN_BOUNDS.maxZ - radius;
                const x = minX + Math.random() * (maxX - minX);
                const z = minZ + Math.random() * (maxZ - minZ);
                if (isHole(x, z)) continue;
                return { x, z };
            }
            return { x: 0, z: 0 };
        }

        for (let i = 0; i < 40; i++) {
            // 5x absolute scale (relative to original) means 0.5 local scale inside 10x machine
            const b = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 1, 0.5) })
            );
            const spawn = getBallSpawnPosition();
            b.position.set(spawn.x, FLOOR_TOP_Y + 0.15 + 0.05, spawn.z);
            b.userData.type = 'ball';
            b.userData.mass = 0.6;
            machine.add(b);
            balls.push(b);
            const ballShape = new CANNON.Sphere(0.15 * WORLD_SCALE);
            b.userData.bodyRadius = 0.15;
            addDynamicBody(b, ballShape, b.userData.mass);
        }

        const loader = new GLTFLoader();
        const prizes = [];
        // Updated model list based on directory contents
        const modelNames = ['donald', 'eric', 'kristen', 'kyle', 'rochelle', 'vickie'];

        modelNames.forEach(name => {
            // Using relative path assuming index.html is in root and models in models/
            loader.load(`./models/${name}.glb`, (gltf) => {
                const m = gltf.scene;
                // Scale 1/3 of 5.0 is approx 1.66
                // 5x absolute scale -> 0.5x local (Original 1.7 * 0.5 = 0.85)
                m.scale.set(PRIZE_SCALE, PRIZE_SCALE, PRIZE_SCALE);
                m.userData.baseScale = new THREE.Vector3(PRIZE_SCALE, PRIZE_SCALE, PRIZE_SCALE);
                m.userData.mass = 1.8;
                m.userData.type = 'prize';
                m.position.set(0, 0, 0);
                m.updateMatrixWorld(true);
                const bounds = new THREE.Box3().setFromObject(m);
                const sphere = new THREE.Sphere();
                bounds.getBoundingSphere(sphere);
                const visualRadius = Math.max(0.6, sphere.radius / MACHINE_SCALE);
                const physicsRadius = Math.min(1.1, Math.max(0.45, visualRadius * 0.32));
                const spawn = getPrizeSpawnPosition(physicsRadius);
                m.position.set(spawn.x, FLOOR_TOP_Y + physicsRadius + 0.08, spawn.z);
                machine.add(m);
                prizes.push(m);
                m.userData.bodyRadius = physicsRadius;
                m.userData.visualRadius = visualRadius;
                const prizeShape = new CANNON.Sphere(physicsRadius * WORLD_SCALE);
                addDynamicBody(m, prizeShape, m.userData.mass);
            }, undefined, (error) => {
                console.error(`Error loading ${name}.glb:`, error);
            });
        });

        // Game Logic & Controls
        const CLAW_STATES = {
            IDLE: 0,
            DROPPING: 1,
            WAIT_BOTTOM: 2,
            CLOSING: 3,
            WAIT_GRAB: 4,
            RISING: 5,
            MOVING_CORNER: 6,
            WIGGLE_STOP: 7,
            WAIT_DROP: 8,
            OPENING: 9,
            RETURNING: 10
        };

        let clawState = CLAW_STATES.IDLE;
        let stateTimer = 0;
        let grabbed = null;
        let grabbedBody = null;
        let clawVelocity = { x: 0, z: 0 };
        const keyState = { left: false, right: false, up: false, down: false };
        const CLAW_SPEED = 0.05;
        const LIMIT_X = 3.5;
        const LIMIT_Z = 3.5;
        const GRAB_RADIUS = 3.6;
        const GRAB_BASE_CHANCE = 0.85;
        const SLIP_BASE = 0.035;
        const SLIP_GRIP_PENALTY = 0.15;
        const SLIP_WEIGHT_PENALTY = 0.08;
        const WEIGHT_MAP = { ball: 0.8, prize: 1.2 };
        const PRIZE_SCALE = 4.25;
        let currentSlipRisk = 0;
        // Start open with negative angle
        let targetFingerAngle = -Math.PI / 4;

        let wiggleTime = 0;
        let wiggleAmp = 0;

        // Joystick
        const joystickManager = nipplejs.create({
            zone: document.getElementById('zone_joystick'),
            mode: 'static',
            position: { left: '50%', top: '50%' },
            color: 'red'
        });

        joystickManager.on('move', (evt, data) => {
            if (data.vector && clawState === CLAW_STATES.IDLE) {
                audio.ctx.resume(); // Ensure context is running
                clawVelocity.x = data.vector.x * CLAW_SPEED;
                clawVelocity.z = -data.vector.y * CLAW_SPEED;
                const speed = Math.hypot(clawVelocity.x, clawVelocity.z);
                audio.startMotor(200 + speed * 1000);
            }
        });

        joystickManager.on('end', () => {
            clawVelocity.x = 0;
            clawVelocity.z = 0;
            audio.stopMotor();
        });

        function applyKeyboardMovement() {
            if (clawState !== CLAW_STATES.IDLE) return;
            const x = (keyState.right ? 1 : 0) - (keyState.left ? 1 : 0);
            const z = (keyState.down ? 1 : 0) - (keyState.up ? 1 : 0);
            clawVelocity.x = x * CLAW_SPEED;
            clawVelocity.z = z * CLAW_SPEED;
            if (x !== 0 || z !== 0) {
                const speed = Math.hypot(clawVelocity.x, clawVelocity.z);
                audio.startMotor(200 + speed * 1000);
            } else {
                audio.stopMotor();
            }
        }

        function forcePrizeUnderClaw() {
            if (!testMode || prizes.length === 0) return;
            let closest = prizes[0];
            let best = clawGroup.position.distanceTo(prizes[0].position);
            for (let i = 1; i < prizes.length; i++) {
                const d = clawGroup.position.distanceTo(prizes[i].position);
                if (d < best) { best = d; closest = prizes[i]; }
            }
            const liftY = CLAW_BOTTOM_Y - (closest.userData.bodyRadius ?? 0.6);
            closest.position.set(clawGroup.position.x, Math.max(FLOOR_TOP_Y + 0.4, liftY), clawGroup.position.z);
            const body = physicsBodies.get(closest);
            if (body) {
                const worldPos = toWorld(closest.position);
                body.position.set(worldPos.x, worldPos.y, worldPos.z);
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                dropClaw();
                return;
            }
            if (e.key === 'b' || e.key === 'B') {
                forcePrizeUnderClaw();
                return;
            }
            if (e.key === 'ArrowLeft' || e.key === 'left' || e.key === 'a' || e.key === 'A') keyState.left = true;
            if (e.key === 'ArrowRight' || e.key === 'right' || e.key === 'd' || e.key === 'D') keyState.right = true;
            if (e.key === 'ArrowUp' || e.key === 'up' || e.key === 'w' || e.key === 'W') keyState.up = true;
            if (e.key === 'ArrowDown' || e.key === 'down' || e.key === 's' || e.key === 'S') keyState.down = true;
            applyKeyboardMovement();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'left' || e.key === 'a' || e.key === 'A') keyState.left = false;
            if (e.key === 'ArrowRight' || e.key === 'right' || e.key === 'd' || e.key === 'D') keyState.right = false;
            if (e.key === 'ArrowUp' || e.key === 'up' || e.key === 'w' || e.key === 'W') keyState.up = false;
            if (e.key === 'ArrowDown' || e.key === 'down' || e.key === 's' || e.key === 'S') keyState.down = false;
            applyKeyboardMovement();
        });

        // Drop Button
        dropButton.onclick = dropClaw;

        function setFingers(open) {
            targetFingerAngle = open ? -Math.PI / 2.5 : Math.PI / 4; // Wide open / Tight close
        }


        function dropClaw() {

            audio.ctx.resume();
            if (!clawReady) return;
            if (clawState === CLAW_STATES.IDLE && (turns > 0 || credits > 0)) {
                if (turns > 0) {
                    turns--;
                } else if (credits > 0) {
                    credits--;
                }

                clawState = CLAW_STATES.DROPPING;
                lights.setMode('PLAY');
                setFingers(true);
                updateUI();
                audio.startMotor(150); // Lower pitch for drop
            } else if (turns === 0 && credits === 0) {
                alert("Insert Coin!");
            }
        }

        function tryGrab() {
            let found = null;
            let best = Infinity;
            [...balls, ...prizes].forEach(obj => {
                const d = clawGroup.position.distanceTo(obj.position);
                if (d < GRAB_RADIUS && d < best) {
                    best = d;
                    found = obj;
                }
            });
            if (found) {
                const type = found.userData.type || 'prize';
                const weight = WEIGHT_MAP[type] || 1;
                const gripQuality = Math.max(0, 1 - (best / GRAB_RADIUS));
                const chance = testMode ? 1 : Math.min(1, GRAB_BASE_CHANCE * gripQuality * (1 / weight));
                if (Math.random() < chance) {
                    grabbed = found;
                    grabbed.userData.gripQuality = gripQuality;
                    grabbed.userData.weight = weight;
                    const radius = grabbed.userData.bodyRadius ?? 0.6;
                    const minCenterY = FLOOR_TOP_Y + radius;
                    const maxOffset = Math.max(0.3, clawGroup.position.y - minCenterY);
                    grabbed.userData.grabOffset = Math.min(radius + 0.3, maxOffset);
                    const body = physicsBodies.get(grabbed);
                    if (body) {
                        grabbedBody = body;
                        body.type = CANNON.Body.KINEMATIC;
                        body.mass = 0;
                        body.updateMassProperties();
                        body.velocity.set(0, 0, 0);
                        body.angularVelocity.set(0, 0, 0);
                        body.collisionResponse = false;
                    }
                    audio.playTone(400, 'sine', 0.1);
                }
            }
        }

        function releaseGrabbedToFloor() {
            if (!grabbed) return;
            const dropY = FLOOR_TOP_Y + (grabbed.userData.bodyRadius ?? 0.4);
            grabbed.position.set(clawGroup.position.x, dropY, clawGroup.position.z);
            const body = physicsBodies.get(grabbed);
            if (body) {
                body.type = CANNON.Body.DYNAMIC;
                body.mass = grabbed.userData.mass ?? 1;
                body.updateMassProperties();
                body.collisionResponse = true;
                const worldPos = toWorld(grabbed.position);
                body.position.set(worldPos.x, worldPos.y, worldPos.z);
                body.velocity.set(0, 0, 0);
                body.angularVelocity.set(0, 0, 0);
            }
            grabbed = null;
            grabbedBody = null;
            currentSlipRisk = 0;
            audio.playTone(180, 'sawtooth', 0.2);
            lights.setMode('LOSE');
        }

        function maybeSlip(dt) {
            if (!grabbed || testMode) {
                currentSlipRisk = 0;
                return false;
            }
            const gripQuality = grabbed.userData.gripQuality ?? 0.5;
            const weight = grabbed.userData.weight ?? 1;
            const slipPerSecond = SLIP_BASE + (1 - gripQuality) * SLIP_GRIP_PENALTY + Math.max(0, weight - 1) * SLIP_WEIGHT_PENALTY;
            currentSlipRisk = slipPerSecond;
            const slipChance = 1 - Math.pow(1 - slipPerSecond, dt);
            if (Math.random() < slipChance) {
                releaseGrabbedToFloor();
                return true;
            }
            return false;
        }

        function checkWin() {
            if (!grabbed) return;
            // Dropped in hole?
            lights.setMode('WIN');
            audio.playWin();
            const wasBall = balls.includes(grabbed);
            if (wasBall) { freeTurns++; turns++; }
            else { prizeCount++; tickets += 10; }
            if (grabbed.parent) {
                grabbed.parent.remove(grabbed);
            } else {
                scene.remove(grabbed);
            }
            if (wasBall) {
                const idx = balls.indexOf(grabbed);
                if (idx !== -1) balls.splice(idx, 1);
            } else {
                const idx = prizes.indexOf(grabbed);
                if (idx !== -1) prizes.splice(idx, 1);
            }
            removePhysicsForMesh(grabbed);
            grabbed = null;
            grabbedBody = null;
            currentSlipRisk = 0;
            updateUI();
        }

        // Timer
        setInterval(() => {
            // Disabled auto-increment
        }, 60000);

        // Animation Loop
        const clock = new THREE.Clock();

        function update(dt) {
            lights.update(dt);
            dust.rotation.y += dt * 0.02;
            if (!grabbed) currentSlipRisk = 0;

            // Finger Animation
            fingers.forEach(f => {
                // Interpolate angle
                if (f.userData.currentAngle === undefined) f.userData.currentAngle = 0;
                f.userData.currentAngle += (targetFingerAngle - f.userData.currentAngle) * 5 * dt;

                // Rotate around calculated axis
                if (f.userData.axis) {
                    f.quaternion.setFromAxisAngle(f.userData.axis, f.userData.currentAngle);
                } else {
                    f.rotation.x = f.userData.currentAngle; // Fallback
                }
            });

            // Wiggle Animation
            if (wiggleAmp > 0.01) {
                wiggleTime += dt * 10;
                wiggleAmp *= 0.95; // Damping
                clawPivot.rotation.z = Math.sin(wiggleTime) * wiggleAmp;
            } else {
                clawPivot.rotation.z = 0;
            }

            // Update Cord (Stretch to roof at ROOF_Y)
            const distToRoof = Math.max(0.2, ROOF_Y - clawGroup.position.y);
            cord.scale.y = distToRoof;
            cord.position.y = distToRoof / 2 + 0.2;

            // State Machine
            switch (clawState) {
                case CLAW_STATES.IDLE:
                    // Joystick Movement
                    clawGroup.position.x += clawVelocity.x;
                    clawGroup.position.z += clawVelocity.z;

                    // Constraints
                    clawGroup.position.x = Math.max(-LIMIT_X, Math.min(LIMIT_X, clawGroup.position.x));
                    clawGroup.position.z = Math.max(-LIMIT_Z, Math.min(LIMIT_Z, clawGroup.position.z));
                    break;

                case CLAW_STATES.DROPPING:
                    clawGroup.position.y -= 1.5 * dt; // Slower drop
                    if (clawGroup.position.y <= CLAW_BOTTOM_Y) {
                        clawGroup.position.y = CLAW_BOTTOM_Y;
                        audio.stopMotor();
                        clawState = CLAW_STATES.WAIT_BOTTOM;
                        stateTimer = 0;
                    }
                    break;

                case CLAW_STATES.WAIT_BOTTOM:
                    stateTimer += dt;
                    if (stateTimer > 0.5) {
                        clawState = CLAW_STATES.CLOSING;
                    }
                    break;

                case CLAW_STATES.CLOSING:
                    if (!clawReady || fingers.length === 0) break;
                    setFingers(false); // Close
                    // Wait for fingers to visually close
                    // Check against target angle using userData
                    if (Math.abs(fingers[0].userData.currentAngle - targetFingerAngle) < 0.1) {
                        tryGrab();
                        clawState = CLAW_STATES.WAIT_GRAB;
                        stateTimer = 0;
                    }
                    break;

                case CLAW_STATES.WAIT_GRAB:
                    stateTimer += dt;
                    if (stateTimer > 1.0) {
                        clawState = CLAW_STATES.RISING;
                        audio.startMotor(250); // Higher pitch rise
                    }
                    break;

                case CLAW_STATES.RISING:
                    clawGroup.position.y += 1.5 * dt;
                    maybeSlip(dt);
                    if (clawGroup.position.y >= CLAW_TOP_Y) {
                        clawGroup.position.y = CLAW_TOP_Y;
                        audio.stopMotor();
                        clawState = CLAW_STATES.MOVING_CORNER;
                        audio.startMotor(200);
                    }
                    break;

                case CLAW_STATES.MOVING_CORNER:
                    // Move to (-2, 2) approx (Center of hole)
                    const targetX = -2;
                    const targetZ = 2; // Front left is +Z in this camera setup (camera at +Z positive)

                    const dx = targetX - clawGroup.position.x;
                    const dz = targetZ - clawGroup.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < 0.1) {
                        clawGroup.position.x = targetX;
                        clawGroup.position.z = targetZ;
                        audio.stopMotor(); // SCRATCH STOP
                        clawState = CLAW_STATES.WIGGLE_STOP;
                        wiggleAmp = 0.2; // Trigger wiggle
                        stateTimer = 0;
                    } else {
                        const move = Math.min(dist, 4 * dt);
                        clawGroup.position.x += (dx / dist) * move;
                        clawGroup.position.z += (dz / dist) * move;
                        maybeSlip(dt);
                    }
                    break;

                case CLAW_STATES.WIGGLE_STOP:
                    stateTimer += dt;
                    if (stateTimer > 1.0) {
                        clawState = CLAW_STATES.OPENING;
                    }
                    break;

                case CLAW_STATES.OPENING:
                    setFingers(true);
                    if (grabbed) {
                        // Drop logic
                        checkWin();
                    } else {
                        // Empty drop
                        if (clawState !== CLAW_STATES.WAIT_DROP) {
                            audio.playTone(150, 'sawtooth', 0.3); // Fail sound
                            lights.setMode('LOSE');
                        }
                    }
                    clawState = CLAW_STATES.WAIT_DROP;
                    stateTimer = 0;
                    break;

                case CLAW_STATES.WAIT_DROP:
                    stateTimer += dt;
                    if (stateTimer > 1.0) {
                        clawState = CLAW_STATES.RETURNING;
                        audio.startMotor(200);
                    }
                    break;

                case CLAW_STATES.RETURNING:
                    // Return to 0,0
                    const rdx = 0 - clawGroup.position.x;
                    const rdz = 0 - clawGroup.position.z;
                    const rdist = Math.sqrt(rdx * rdx + rdz * rdz);

                    if (rdist < 0.1) {
                        clawGroup.position.x = 0;
                        clawGroup.position.z = 0;
                        audio.stopMotor();
                        clawState = CLAW_STATES.IDLE;
                        lights.setMode('IDLE');
                    } else {
                        const move = Math.min(rdist, 4 * dt);
                        clawGroup.position.x += (rdx / rdist) * move;
                        clawGroup.position.z += (rdz / rdist) * move;
                    }
                    break;
            }

            // Safety clamp to avoid overshoot in non-IDLE states
            clawGroup.position.x = Math.max(-LIMIT_X, Math.min(LIMIT_X, clawGroup.position.x));
            clawGroup.position.z = Math.max(-LIMIT_Z, Math.min(LIMIT_Z, clawGroup.position.z));

            // Grabbed Object Sync
            if (grabbed) {
                const offset = grabbed.userData.grabOffset ?? 1.0;
                grabbed.position.set(clawGroup.position.x, clawGroup.position.y - offset, clawGroup.position.z);
                if (grabbedBody) {
                    const worldPos = toWorld(grabbed.position);
                    grabbedBody.position.set(worldPos.x, worldPos.y, worldPos.z);
                }
            }

            world.step(1 / 60, dt, 3);
            physicsMeshes.forEach((mesh) => {
                if (mesh === grabbed) return;
                const body = physicsBodies.get(mesh);
                if (!body) return;
                mesh.position.set(body.position.x / WORLD_SCALE, body.position.y / WORLD_SCALE, body.position.z / WORLD_SCALE);
                mesh.quaternion.set(body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w);
            });

            prizes.forEach((p) => {
                if (!p.userData.baseScale) return;
                const base = p.userData.baseScale;
                const squish = new THREE.Vector3(base.x * 1.18, base.y * 0.68, base.z * 1.18);
                const target = p === grabbed ? squish : base;
                p.scale.lerp(target, 9 * dt);
            });

            controls.update();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            update(dt);
            render();
        }

        function resizeRenderer() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', resizeRenderer);

        // Fullscreen toggle
        document.addEventListener('keydown', (e) => {
            if (e.key && e.key.toLowerCase() === 'f') {
                if (!document.fullscreenElement) {
                    renderer.domElement.requestFullscreen().catch(() => { });
                } else {
                    document.exitFullscreen().catch(() => { });
                }
            }
        });

        document.addEventListener('fullscreenchange', resizeRenderer);

        window.advanceTime = (ms) => {
            const step = 1 / 60;
            const steps = Math.max(1, Math.round((ms / 1000) / step));
            for (let i = 0; i < steps; i++) update(step);
            render();
        };

        function renderGameToText() {
            const payload = {
                mode: clawState,
                coords: 'x right, y up, z toward camera',
                clawReady,
                slipRisk: Number(currentSlipRisk.toFixed(3)),
                claw: {
                    x: Number(clawGroup.position.x.toFixed(2)),
                    y: Number(clawGroup.position.y.toFixed(2)),
                    z: Number(clawGroup.position.z.toFixed(2)),
                    grabbed: grabbed ? true : false,
                    grabQuality: grabbed ? Number((grabbed.userData.gripQuality ?? 0).toFixed(2)) : 0,
                    slipRisk: Number(currentSlipRisk.toFixed(3)),
                    clawReady
                },
                counts: {
                    prizeCount,
                    freeTurns,
                    turns,
                    credits,
                    tickets
                },
                lights: { mode: lights.mode },
                balls: balls.map(b => ({ x: Number(b.position.x.toFixed(2)), y: Number(b.position.y.toFixed(2)), z: Number(b.position.z.toFixed(2)) })),
                prizes: prizes.filter(p => p.parent).map(p => ({ x: Number(p.position.x.toFixed(2)), y: Number(p.position.y.toFixed(2)), z: Number(p.position.z.toFixed(2)) })),
                catalogVisible: window.getComputedStyle(catalogEl).display !== 'none',
                viewport: { w: window.innerWidth, h: window.innerHeight },
                fullscreen: !!document.fullscreenElement,
                testMode
            };
            return JSON.stringify(payload);
        }

        window.render_game_to_text = renderGameToText;

        animate();
        updateUI();
    </script>
</body>

</html>
